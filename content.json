{"meta":{"title":"Cheng","subtitle":null,"description":"This is my personal blog using to record and share the technolegy knowlege and feeling of life.","author":"Chengshiwei","url":"http://swcheng.com"},"pages":[{"title":"About","date":"2019-08-25T08:42:51.591Z","updated":"2019-05-19T09:47:37.269Z","comments":true,"path":"about/index.html","permalink":"http://swcheng.com/about/index.html","excerpt":"","text":"My Creation And Participation: 地点 时间 名称 描述 URL 学校 2017-03 ~ 2018-03 ShareBook 刚开始做这个项目的时候，自己连SQL都还没学过，凭着自己的热情和一点Java基础就开始了，在十一月的时候已经完成大部分内容，后续有一些轻微的修补和添加 https://github.com/cheng-github/ShareBooks 学校 2017-12 ~ 2018-01 Sniffer TCP/IP协议课程设计，一个网络嗅探器，为其添加了写入文件功能 https://github.com/cheng-github/Sniffer 学校 2018-05 ~ 2018-10 Hexo博客 Start to express! http://swcheng.com Teradata 2018-07 ~ 2018-12 Java Web开发实习 第一份实习，让自己更加清楚自己想要的是什么 无 \"Be optimistic,everything will be good\" Sees like a child Give like a saint Feel like an angel Never mind the broken wings And speak like a picture Cry like the rain Shine like the star As long as the fire remains -STEFANIE «Someone»"},{"title":"Categories","date":"2019-05-19T09:42:05.871Z","updated":"2019-05-19T09:42:05.871Z","comments":true,"path":"categories/index.html","permalink":"http://swcheng.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-05-19T09:42:06.903Z","updated":"2019-05-19T09:42:06.903Z","comments":true,"path":"tags/index.html","permalink":"http://swcheng.com/tags/index.html","excerpt":"","text":"My Creation And Participation: 地点 时间 名称 描述 URL 学校 2017-03 ~ 2018-03 ShareBook 刚开始做这个项目的时候，自己连SQL都还没学过，凭着自己的热情和一点Java基础就开始了，在十一月的时候已经完成大部分内容，后续有一些轻微的修补和添加 https://github.com/cheng-github/ShareBooks 学校 2017-12 ~ 2018-01 Sniffer TCP/IP协议课程设计，一个网络嗅探器，为其添加了写入文件功能 https://github.com/cheng-github/Sniffer 学校 2018-05 ~ 2018-10 Hexo博客 Start to express! http://swcheng.com Teradata 2018-07 ~ 2018-12 Java Web开发实习 第一份实习，让自己更加清楚自己想要的是什么 无 \"Be optimistic,everything will be good\" Sees like a child Give like a saint Feel like an angel Never mind the broken wings And speak like a picture Cry like the rain Shine like the star As long as the fire remains -STEFANIE «Someone»"}],"posts":[{"title":"Think Different,Refuse Repeating","slug":"Think Different,Refuse Repeating","date":"2019-12-11T07:56:00.000Z","updated":"2019-12-11T09:30:56.537Z","comments":true,"path":"2019/12/11/Think Different,Refuse Repeating/","link":"","permalink":"http://swcheng.com/2019/12/11/Think Different,Refuse Repeating/","excerpt":"Think Different是苹果公司1997年的广告语，由乔布斯亲自编写。在广告词的原意是致疯狂的人，但是我更喜欢将把它解释为，”拒绝不断重复，换个思考方式”。","text":"Think Different是苹果公司1997年的广告语，由乔布斯亲自编写。在广告词的原意是致疯狂的人，但是我更喜欢将把它解释为，”拒绝不断重复，换个思考方式”。 前段时间把Webpack的配置文档通读了一遍，看文档看的快吐了。所以最近打算学习一个Vue的开源项目，代码下载下来，在本地运行后有点迷茫，因为不知道如何去学习这个项目。想为它们的项目修一些Issue，但浏览了一下大部分的Issue，发现这些Issue都不能称为真正的Issue，很多都是一些基本知识都不懂的人随意提的东西，简单来说就是Issue数量虽多，但是质量太低。 我感觉现在的开源环境，一个优秀点的开源项目，大家把从向它进行索取看成了理所当然。当自己碰到到点问题时，就像没头苍蝇一样到处求助，从来没有去想过先去花时间去学习自己不懂的知识，也更加不会想要去说做点什么帮助这个项目变的更好。其实我是很鄙视这帮人的，觉得这类人根本就不配称为程序员，而往往这类人又确实数量庞大，有点为之奈何的感觉。我感觉要是我这小爆脾气去维护一个开源项目，估计早就把这提的弱智Issue的人骂了个遍。 话说回来，虽然哪里都有弱智，但开源世界的大神也是超级多。要是没有这些牛皮的开源项目工作者的无私贡献，软件开发也很难发展到现如今的水平。记得自己第一次开始学习的开源项目是Android类的，为了开发一个APP，自己是硬生生的根据源码从头到尾将那个开源项目手写了一遍。这个方法虽然笨，但是对于初学来说确实有比较大的帮助，现在想想这种从零完全模仿的方式还是不可取，一是太累，二是效率太低。 所以最近当自己打算去学习一个新的开源项目的时候，我想去看看人家是怎么学习开源项目的，学习一下人家的经验。有一篇文章给了我一些启示。虽然这个老哥是专注于后端的，但是这种学习方式的经验也确实可以被借鉴。文章大致的将学习划分了五个步骤，安装、运行、原理研究、实际测试、源码研究。将一个项目运行起来大概是最简单的，首先了解这个项目是干什么的，然后根据文档引导一步步来就好了。 我感觉我还是比较懒，一般运行起一个项目后就没下文了，无论是项目的运行还是框架的使用，自己都持有简单的态度，认为第一步先掌握它们的使用就好了，基本不会去进行下面的三个步骤。有时候当时可能只是先认为先掌握使用，然后再去掌握原理，或者自己去实现一个DEMO，但是到后来就很懒，不想去做这些非必要的事情。这样下去，其实对技术毫无提升，时间长了之后就都是在不断基于之前的知识在重复做过的内容，工作也会变的越来越乏味。 正如此次计划学习一个开源项目一样，首先我们要知道为什么要去学习这个项目，是为了去学习项目使用的技术，或者某个功能是如何实现的，还是项目的配置，还是项目的结构，还是去学习项目的优秀编码思维等。漫无目的的学习其实只能是事倍功半，我们应该尽量避免这种事倍功半行为，时间本身就是一种成本，如果花费了大量的成本去做一件对你而言依然是重复的事情，还不如去做一些其它的事情开心一下。 什么是Think Different呢，我认为无论在生活还是工作中，都会容易陷入一个不断重复的漩涡。这种漩涡很可怕，它会让你失去想象力，完全沦为一个车间流水线上的工人，只会为了完成基本的任务不断Repeat。既然这样，为何我们不尝试去思考一些不同的东西呢?既然这种不断重复很傻，我们为何不去尝试去做一些更棒的事情呢，或者直白点说去做一些牛逼的事情呢? 比如一个前端程序员，在掌握了框架的使用之后，为什么不可以将自己工作的时间分配一点出来去了解框架的原理，然后再在空闲时间自己根据原理自己去实现这个框架呢?在这个过程中，你肯定会获得很多不一样的体验，而且你的技术肯定会因此得到提升，因为你懂得很多别人不懂的东西，并且你知道每个东西的内部是怎样的而不是简单只会根据文档去使用工具的人。或者调侃一下说，知道如何制造工具和只会使用工具是人和猴子的本质区别。 我认为并不是敢于Think Different 的人有多疯狂，Think Different有疯狂的含义我认为更多是乔布斯的广告营销的手段。Think Different应该是一种好的习惯，当你去这么做的时候，你会发现一切没你想的那么困难，毕竟大家都是智力正常的人嘛。当你站在另外一个角度的思考的时候，发现一切会变的豁然开朗。尝试去让思考如何改变成为一种习惯，努力别让惰性的去适应环境变成一种习惯。 不过嘛，Think Different是一个好习惯不错，但是更重要的是让自己开心。不要为了Different而去Different，那样是很傻的，因为只不过是让自己徒增痛苦。好比你让一个不喜欢爬山的人去让他去尝试爬不同类型的山，他不会觉得这种改变很有满足感，只会觉得这种是一种高强度的体力活，迟早把他给累死。任何道理都不是通用的，还得根据每个人的情况去做一些调整，照搬别人说的话在我看来也是很傻的一种行为，就像那句话说的，如人饮水，冷暖自知。 Happy Life &amp; Happy Coding","categories":[],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"Vue基础 - 组件","slug":"Vue基础-组件","date":"2019-10-28T05:23:00.000Z","updated":"2020-07-16T16:18:17.479Z","comments":true,"path":"2019/10/28/Vue基础-组件/","link":"","permalink":"http://swcheng.com/2019/10/28/Vue基础-组件/","excerpt":"组件是Vue设计的核心思想，Vue应用也是由一个个组件组成的，组件可以被复用，也可以根据情况动态显示不同的组件。在Vue的组件中，主要包括template、script以及style三个内容，template是编写的组件的html模版(也可以使用JSX)，里面包含的是页面的基础的html内容，可以使用Vue指令去进行一些额外逻辑的处理；script包含Vue组件内部的一些数据，方法，生命周期钩子等；style中是为组件编写的一些css样式，如果在style中加上scope表示这些样式作用域为组件内，如果没有则表示定义的全局样式。","text":"组件是Vue设计的核心思想，Vue应用也是由一个个组件组成的，组件可以被复用，也可以根据情况动态显示不同的组件。在Vue的组件中，主要包括template、script以及style三个内容，template是编写的组件的html模版(也可以使用JSX)，里面包含的是页面的基础的html内容，可以使用Vue指令去进行一些额外逻辑的处理；script包含Vue组件内部的一些数据，方法，生命周期钩子等；style中是为组件编写的一些css样式，如果在style中加上scope表示这些样式作用域为组件内，如果没有则表示定义的全局样式。 组件注册 Vue的组件需要定义且注册之后才可以与其它组件配合工作，上面叙述的是组件在.vue模板里的书写方式，如果我们直接在JS中全局定义并注册一个Vue组件的方式为： 123456789// 定义一个名为 button-counter 的新组件Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) 当一个组件完成注册之后，就可以被使用在其它组件之中了，全局注册的组件可以在整个Vue应用中使用，比如我们可以在html模板中这样定义， 123&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 所有Vue应用仅有一个根实例，根实例与其它组件的区别是它具备一个el属性，这个属性在其它组件中并不存在，el属性用于将vue应用绑定到唯一的DOM节点上。对于一个已经定义并全局注册的组件，你可以在任意一个地方进行复用， 12345&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 在这里的button-counter组件中，每个组件都维护自己的数据独立工作，当这份数据是从外部传入的时候，这个规则可能不再成立。相同的组件只可能因为数据不同而显示不同的样式，当依赖式数据改动的时候，视图将会被相应更新。所以为了维护每个组件的独立，在组件内部定义data属性的时候，必须使用方法返回一个对象而不能直接定义为一个对象，正确添加data的方式应该是这样： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 全局注册过的组件在任何地方都可用，但是有时候我们不需要去全局定义一个组件，因为对于很多使用频率较低组件来说，并不需要进行全局注册，只进行局部注册即可，过多的全局注册会导致用户增加下载的JS的体积。对于局部注册的组件，只可以在引入其的组件中使用，不可以在其它组件的模板中使用。局部定义一个组件的方式很简单，在JS中直接定义的方式为： 123var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125;var ComponentC = &#123; /* ... */ &#125; 在需要引入其的组件中的components属性中，添加指向这个对象的引用，(局部注册的组件只可以在它自己的模板中使用，不可使用在其子组件中，也就是说，这里同时引入A和B，无法在B的模板中使用A，要想在B中使用A，必须在B中单独引入) 1234567new Vue(&#123; el: '#app', components: &#123; 'component-a': ComponentA, 'component-b': ComponentB &#125;&#125;) 或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像： 12345678import ComponentA from './ComponentA.vue'export default &#123; components: &#123; ComponentA &#125;, // ...&#125; 在引入局部组件之后，在模板中使用只需要引入其在components中编写的组件属性名称，比如这里定义的属性名称为ComponentA，那么在模板中就可以编写，这样看上去不太符合标准的html标签的写法，所幸的是，Vue中两种写法都支持，当你使用PascalCase的写法的时候，你依然可以在模板中使用&lt;/component-a&gt;这样的写法。但如果你本身就在components中使用的是kebab-case这样的写法，那么在模板中你也只能在这里面使用kebab-case这样的写法。 基础组件全局注册 对于一些基础组件，这类组件相对比较通用，如果一个个去导入这些组件，那么会导致在很多组件中有大量包含基础组件的长列表，这时候我们想要在全局注册这些组件。如果你使用webpack这类前端打包工具，那么你可以使用require.context很方便的一次引入大量的基础组件， 123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 获取和目录深度无关的文件名 fileName .split('/') .pop() .replace(/\\.\\w+$/, '') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;); 组件PropProp定义和传递 组件中的数据分成两个部分，一部分是由父组件传递给自己的，就是这里说的Prop，另一部分是自身的数据，也就是data属性定义的部分。在组件中定义一个Prop最简单的方式， 1234Vue.component('blog-post', &#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'&#125;) 最简单的在父组件中为其赋值的方式， 123&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Blogging with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Why Vue is so fun\"&gt;&lt;/blog-post&gt; 一个组件可以拥有任意数量的Prop，在组件中访问Prop的属性的方式和data属性一样，这里的title不仅可以是字符串，可以是任何类型的值(对象，数组，布尔值…)。更方便的是，可以配合使用v-for去遍历生成一个子组件列表， 12345&lt;blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; 一个需要注意的地方是，在HTML中DOM是不区分大小写的，也就是说浏览器会把所有大写字母解释为小写字母，如果使用DOM中的模板，如果需要对camel-case格式的prop赋值必须在模板中用与其等价的kebab-case命名。 12345678Vue.component('blog-post', &#123; // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'&#125;)&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; 但是如果使用字符串模板，那么这条限制就不存在了，那么什么是字符串模板什么是DOM模板呢？DOM模板是指能被浏览器解析的模板，DOM模板和元素的html混合在一起进行定义，比如下面的例子，id为demo的div既是位于html中，又作为vue的一个组件被定义，这就被称为DOM模板， 1234567891011121314151617&lt;body&gt; &lt;!-- html模板 --&gt; &lt;div id=\"demo\" title=\"i love jack\"&gt; &lt;span :customId=\"id\"&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; let obj = &#123; message: 'hello,world', id: 'JS脚本模板' &#125; var vm = new Vue(&#123; el: '#demo', data: obj, prop: ['title'] &#125;) &lt;/script&gt;&lt;/body&gt; 字符串模板是定义在js代码中用字符串包裹起来进行定义的vue组件，这种方式被称为字符串模板，比如下面的全局注册和局部组件定义都是字符串模板的使用方式，(注意，通过字符串模板定义的元素，会替换挂载的元素) 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=\"template\"&gt;&lt;/div&gt; &lt;script type=\"x-template\" id=\"optioncompTemp\"&gt; &lt;option&gt;a&lt;/option&gt; &lt;/script&gt; &lt;script&gt; Vue.component('my-component', &#123; props: ['param'], template: ` &lt;div&gt;A custom component&#123;&#123;param&#125;&#125;&lt;/div&gt; ` &#125;) new Vue(&#123; el: '#template', data: &#123; name: 'donghai' &#125;, components: &#123; 'se-com': &#123; props: ['param'], template: '#optioncompTemp' &#125; &#125;, // 字符串模板，替换全部的模板，内联字符串模板 template: ` &lt;ol&gt; &lt;tr is=\"my-component\" :param=\"name\"&gt;&lt;/tr&gt; &lt;tr is=\"se-com\" :param=\"name\" &gt;&lt;/tr&gt; &lt;se-com :param=\"name\"&gt;&lt;/se-com&gt; &lt;/ol&gt; ` &#125;) &lt;/script&gt;&lt;/body&gt; 除了DOM模板和字符串模板之外，在vue中还存在着内联字符串模板以及JS脚本模板模板，内联字符串模板指的是，在一个组件内部引用其它组件的时候，这个被引入的子组件也是直接用字符串表示，而非来自其它形式(如导入一个模板等)方式的引入， 12345678910111213141516171819202122new Vue(&#123; el: '#template', data: &#123; name: 'donghai' &#125;, components: &#123; 'se-com': &#123; props: ['param'], template: `&lt;div&gt;我是第二个组件&#123;&#123;param&#125;&#125;&lt;/div&gt;` &#125; &#125;, // 字符串模板，替换挂载元素 template: ` &lt;ol&gt; &lt;tr is=\"my-component\" :param=\"name\"&gt;&lt;/tr&gt; &lt;tr is=\"se-com\" :param=\"name\" &gt;&lt;/tr&gt; &lt;se-com :param=\"name\"&gt;&lt;/se-com&gt; &lt;/ol&gt; ` &#125;) JS脚本模板指的是使用script标签去声明一个组件的模板， 123456789101112131415161718192021&lt;body&gt; &lt;div id=\"app\"&gt; &lt;select&gt; &lt;option is=\"optioncomp\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;!--模板内容存放区域--&gt; &lt;script type=\"text/x-template\" id=\"optioncompTemp\"&gt; &lt;option&gt;a&lt;/option&gt; &lt;/script&gt; &lt;script&gt; new Vue(&#123; el: '#app', components: &#123; 'optioncomp': &#123; template: '#optioncompTemp' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 但是如果我们使用文件模板，即xxx.vue的方式，在前端工程中就不存在上面提到的大小写的问题了。除此之外，vue模板中定义的组件在一些特定的标签下受到限制，例如ul、ol、table、select这样的元素里允许包含的元素有限制，而另一些像option这样的元素只能出现在某些特定元素的内部。下面这样的方式是不被允许的， 123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 这时候自定义组件my-row会被当成无效的内容，这时候需要使用到特殊的is属性， 123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 另外这个特殊的标签限制只会的一些内容有效，对于下面的情况，则可以在这些被限制的标签中使用自定义模板， 内联字符串模板 单文件组件 (.vue) JS脚本模板 静态传递和动态传递 我们知道可以这样传递到组件中一个静态的值，而且它总是一个字符串类型， 1&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt; 通过v-bind进行动态赋值， 123456789&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=\"post.title + ' by ' + post.author.name\"&gt;&lt;/blog-post&gt; 对于静态赋值，有时候我们想要传递一个数字类型或者布尔类型的时候，是无法做到的，所以这时候我们必须使用动态赋值的方式传递一个js表达式， 123456789101112131415161718192021222324&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt;&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:is-published=\"false\"&gt;&lt;/blog-post&gt;&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:comment-ids=\"[234, 266, 273]\"&gt;&lt;/blog-post&gt;&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author=\"&#123; name: 'Veronica', company: 'Veridian Dynamics' &#125;\"&gt;&lt;/blog-post&gt; 如果你想要在组件中同时定义多个属性，但又不希望把它们都放置在一个对象中，这时候你可能需要写很多赋值语句，vue提供了不带参数的v-bind指令帮助你一次传递一个对象的所有属性， 123456789&lt;blog-post v-bind=\"post\"&gt;&lt;/blog-post&gt;等价于:&lt;blog-postv-bind:id=\"post.id\"v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; 单向数据流 Vue中所有的数据在父组件和自组件中是单向下行绑定的，这意味着，父组件中修改传递到子组件中的prop时，子组件中的数据同样会被修改，但是反之却不行。这样的目的是为了防止子组件的改动影响到父组件中的数据，会导致应用的数据流向难以理解。Vue这样设计是很合理的，因为有时候我们不希望子组件的改动影响到父组件的数据，只有在必要的时候才去这么做，这样使我们对数据具备更多的可控性。 另外在Vue中如果你在子组件中修改了prop，那么控制台会提示一个警告，意味着你不应该这么做。从父组件传递到子组件的prop一般有下面两个用处， 1. 用于传递一个初始值，子组件依赖这个初始值去进行组件的渲染，并将其当作一个本地数据使用。这时候你应该拷贝一份数据到本地，123456props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 2. 这个prop不需要修改，只是用于读取，但是子组件需要修改传递过来的数据源，这时候可以将其设置为一个计算属性， 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 对于对象类型或者数组类型的prop，在从父组件传递到组件中的时候，变量的类型是引用，也就是指向对象和数组的地址，这时候上面的单向数据流就不成立了。就是说单向数据流法则仅当你传递的是一个非对象和数组类型的值的时候才成立，否则子组件和父组件一样会将数据的修改影响到对方。 Prop验证 有时候我们在编写一个组件的时候，自己一般知道需要往里面传递什么类型的值，或者这个Prop的一些限制，但是后面的开发者并不知道这时候需要怎么传递，你可以为这些Prop添加一个验证帮助其它开发者检验错误，当prop验证失败的时候，(开发环境构建版本的)Vue 将会产生一个控制台的警告。如果需要对Prop检查错误，就必须使用对象的语法形式而非数组， 1234567891011121314151617181920212223242526272829303132333435Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) Prop验证发生在组件创建前，也就是说，组件的Prop中的default和validator不可以使用定义在组件data、computed、methods中的属性和方法 type可以是下面原生构造函数中的一个： String Number Boolean Array Object Date Function Symbol 除了这些默认的构造函数，你也可以使用自定义构造函数进行类型的检查， 123456789101112function Person (firstName, lastName) &#123; this.firstName = firstName this.lastName = lastName&#125;Vue.component('blog-post', &#123; props: &#123; author: Person &#125;&#125;) 非Prop特性 非Prop特性这个名字听起来不容易被理解，简单来说，就是指那些在组件中的props属性中没有被声明的，但是又在父组件中向子组件传递的属性。比如下面的例子： 1234567891011&lt;div id=\"app\"&gt; &lt;my-comp data-title=\"learn vue\" class=\"mycls\" style=\"color:red;\"&gt;&lt;/my-comp&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-comp', &#123; template: '&lt;div&gt;我是组件&lt;/div&gt;' &#125;); new Vue(&#123; el: '#app' &#125;);&lt;/script&gt; 这里的my-comp组件中并未定义data-title这个prop，但是又向my-comp标签传递了这个属性，这时候会在这个组件的根元素上添加这个属性，所以这个地方会最终被渲染为， 12345&lt;div id=\"app\"&gt; &lt;div data-title=\"learn vue\" class=\"mycls\" style=\"color:red;\"&gt;&lt;/div&gt;&lt;/div&gt; 这里包括class和style都属于非Prop特性，但不同的是，对于class和style这类非Prop特性，vue有做特殊的处理，前面在Class和Style绑定的时候也提到了，模板中定义的class和style和在模板中传递的值会被合并而不是简单的覆盖。对于其它非Prop特性来说，如果在组件中定义了这个属性，又接着传递了该属性，那么这个非Prop属性会被传递的值覆盖， 12345678910111213&lt;script&gt; Vue.component('my-comp', &#123; template: '&lt;div type=\"inital\"&gt;我是组件&lt;/div&gt;' &#125;); new Vue(&#123; el: '#app' &#125;);&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;my-comp type=\"changed\"&gt;&lt;/my-comp&gt;&lt;/div&gt; 最后这里会被渲染为， 12345&lt;div id=\"app\"&gt; &lt;div type=\"changed\"&gt;&lt;/div&gt;&lt;/div&gt; 当然，有时候你不想要传递的非Prop属性覆盖掉组件中定义的值，你可以组件的选项中设置 inheritAttrs: false去达到这个目的，这样，所有的非Prop属性都不会出现在最后组件根元素的DOM节点上，覆盖也就根本不存在了，(inheritAttrs: false不会影响class和style的绑定) 123456Vue.component('my-component', &#123; inheritAttrs: false, // ...&#125;) 那么，我们如何去获取到这些非Prop属性的值呢，vue提供了$attrs为我们做到了这一点，$attrs是一个包含所有非Prop属性的对象，(不包括class和style)，如果这样如果我们想要将一个非Prop属性绑定到组件的非根元素上时，使用这个属性将变的非常方便， 12345678910111213141516171819202122Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\"&gt; &lt;/label&gt; `&#125;)在base-input标签中&lt;base-input v-model=\"username\" required placeholder=\"Enter your username\"&gt; &lt;/base-input&gt; 这里将会被渲染为， 12345678&lt;label&gt; &#123; \"required\": \"\", \"placeholder\": \"Enter your username\" &#125;&lt;input required=\"required\" placeholder=\"Enter your username\"&gt;&lt;/label&gt; 这样你使用基础自定义组件就像是原始的HTML元素一样，避免了不必要的代码逻辑(添加多余的prop)。 自定义事件事件名 自定义事件名称不像Prop一样存在大小写转换的可能，我们需要精确的匹配一个自定义事件的名称，才可以触发自定义事件的监听器。比如手动触发一个事件， 123this.$emit('myEvent') 如果去监听这个自定义事件的kebab-case是不会有任何效果的， 1234&lt;!-- 没有效果 --&gt;&lt;my-component v-on:my-event=\"doSomething\"&gt;&lt;/my-component&gt; 除此之外，在DOM模板中，v-on指令后面如果定义的是myEvent的话，同样这里的myEvent也会被解析为myevent，这种情况下也会导致myEvent监听器无法被触发，所以不推荐使用camelCase的事件命名，尽可能使用kebab-case的命名方式。 自定义组件的v-model 我们知道，v-model指令可以将组件的行为数据同步到绑定到的data，而v-model的实现原理就是在我们需要在对应的组件上监听原生的DOM事件并使用$emit发出一个自定义事件，然后v-model会在这个对应的自定义事件的监听器中修改绑定的data。v-model默认监听的是原生的input事件以及原生DOM的value属性，但不同的输入组件的事件和属性值会有不同，如果需要改变它的默认行为可以这样做， 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\"&gt;`&#125;) 注意，根据之前所述，如果你需要对checked使用v-bind，必须在props中进行声明。 绑定原生事件 我们都知道v-on可以绑定事件监听器，但是这个的指令的例子中很多在组件标签中监听的是emit的input、change事件啦，在组件的一些原生的html元素中监听的也是input、change事件，这时候开发者会感到迷惑，那么什么时候监听原生的事件什么时候监听的是自定义的事件呢？它们的用法好像看上去没有区别。这时候我们需要借助官方文档的力量帮我们解除迷惑， 用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 看到这里恍然大悟，这就是说，在普通元素上v-on只可以监听原生的事件，如果使用在自定义元素上的时候，两者都可以，这时候默认监听自定义事件，但是如果需要去监听原生的事件需要加上.native修饰符。 在监听原生事件的时候，监听器处理方法只有事件原生对象为唯一的参数。如果使用内联语句，在语句中可以访问一个$event属性， 123v-on:click=\"handle('ok', $event)\" 在使用v-on监听自定义事件的时候，不像监听原生事件一样有一个事件原生对象，这种情况只存在一个从$emit传递过来的额外的参数，有趣的是，这两种方式都使用$event作为传递的变量名称，(虽然都被写为$event，但是含义却大不一样，一个是原生的事件对象，一个是负载信息) 123456789101112131415161718192021&lt;!-- 内联语句，$event只是负载信息，如果需要标识DOM，可以添加data-属性 --&gt;&lt;my-component @my-event=\"handleThis(123, $event)\"&gt;&lt;/my-component&gt;&lt;!-- 也可以直接绑定到一个方法变量，第一个参数就是这个负载信息 --&gt;this.$emit('give-advice', &#123; detail: detailInfo &#125;)&lt;div id=\"emit-example-argument\"&gt; &lt;magic-eight-ball v-on:give-advice=\"showAdvice\"&gt;&lt;/magic-eight-ball&gt;&lt;/div&gt;&lt;!-- 这里的advice的值为 &#123; detail: detailInfo &#125; --&gt;new Vue(&#123; el: '#emit-example-argument', methods: &#123; showAdvice: function (advice) &#123; alert(advice) &#125; &#125;&#125;) 理解了v-on的使用方式，我们可以轻松的绑定一个原生事件，但是我们在自定义组件上使用v-on.native的时候，只会将这个事件绑定到组件的根元素上，对于有些情况来说，这样的绑定会失效，比如下面这样的自定义组件， 123456789&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\"&gt;&lt;/label&gt; 姑且将其称之为base-input，如果我们在这个base-input上监听一个focus事件， 123&lt;base-input v-on:focus.native=\"onFocus\"&gt;&lt;/base-input&gt; 对于这种情况，由于label并不是focusable元素，所以对这个标签添加focus监听器是没有作用的，这时候这个focus监听器并不会被添加到input元素上去，我们的v-on:focus.native也就会起不到任何作用。针对这种情况，Vue提供了一个 $listeners属性，$listeners是一个对象，包含了绑定到这个组件上的根元素的所有事件监听器，(不包括通过.native修饰符添加的监听器，且$listeners仅在2.4+中可用)，一个如果有如下的定义， 123&lt;base-input v-on:mouseover=\"handleMouseOver\" v-on:click=\"handleClick\"&gt;&lt;/base-input&gt; 这样这个$listeners在组件内的值为， 123456&#123; mouseover: handleMouseOver(event) &#123; ... &#125; click: handleClick(value) &#123; ... &#125;,&#125; 所以如果我们需要在组件的子元素绑定一些原生事件，配合上计算属性可以进行一个自定义的添加， 123456789101112131415161718192021222324252627282930313233Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit('input', event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on=\"inputListeners\"&gt; &lt;/label&gt; `&#125;) 这样的话，我们在自定义组件上直接添加监听器就好像在组件子元素上直接添加了原生的监听器，看上去它们就像是一个元素。 .sync 修饰符 之前我们已经在Prop中编写了Vue中组件的单向数据流向，但有时候我们希望改变这个特性，将数据进行双向绑定，使用v-model是一种方式，但其本质是通过自定义事件的监听器去实现的。v-model是针对组件的行为进行的双向绑定，对于一些更加通用的做法，Vue推荐使用update:myPropName的模式去达到这个目的。什么是update:myPropName模式呢？简而言之就是子组件内发出一个update:myPropName的事件，附带上myProp的新值，并在组件根元素上添加这个自定义事件的监听器进行修改。 12345678910&lt;!-- 子组件中 --&gt;this.$emit('update:title', newTitle)&lt;!-- 根组件 --&gt;&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt; 为了方便，Vue提供了.sync 修饰符，也就是说，被.sync修饰符修饰过的变量，只需要在子组件中发出”update:title”这个事件就可以实现数据的双向绑定了。.sync的用法， 123456&lt;text-document v-bind:title.sync=\"doc.title\"&gt;&lt;/text-document&gt;&lt;!-- 设置多个prop的时候 --&gt;&lt;text-document v-bind.sync=\"doc\"&gt;&lt;/text-document&gt; 完整的使用方式， 12345678910111213&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;child :open.sync=\"message\"&gt;&lt;/child&gt;&lt;/div&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;input type=\"text\" :value=\"open\" @input=\"$emit('update:open', $event.target.value)\"&gt; open: &#123;&#123; open &#125;&#125; &lt;/div&gt;&lt;/template&gt; 说白了，.sync修饰符就是语法糖， 1234567:open.sync=\"state\"&lt;!-- 相当于 --&gt;:open=\"state\" @update:open=\"state = $event\" 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用，以及将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，这是因为在vue需要考虑很多边缘情况 插槽 在vue 2.6+中，为插槽这部分内容引入v-slot指令去替代slot和slot-scope，slot和slot-scope已经被废弃，但是在vue2.x中仍然被支持。关于为什么弃用slot-scope，官方在这里解释了 插槽内容 在自定义组件中，虽然我们可以通过数据驱动去定义不同的组件，但是很多时候这种方式只能用于有限种情况的使用，或者说已知情况的定义。所以如果我们想要直观的在组件中内嵌一些元素，就像普通的HTML元素一样，并需要灵活的添加任意的元素类型和数目，这时候插槽的作用就体现出来了。Vue采用标签作为承载这样的内嵌元素的出口，比如你定义一个下面这样的组件，我们称其为navigation-link， 1234567&lt;a v-bind:href=\"url\" class=\"nav-link\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 在使用组件的时候， 12345&lt;navigation-link url=\"/profile\"&gt; Your Profile&lt;/navigation-link&gt; 这样，在渲染的时候，部分就会被替代为”Your Profile”。在插槽内不仅可以添加字符串，还可以添加任意html原生元素和自定义组件标签， 123456789101112131415 &lt;navigation-link url=\"/profile\"&gt; &lt;!-- 添加一个 Font Awesome 图标 --&gt; &lt;span class=\"fa fa-user\"&gt;&lt;/span&gt; Your Profile &lt;/navigation-link&gt; &lt;!-- 甚至包括自定义组件 --&gt; &lt;navigation-link url=\"/profile\"&gt; &lt;!-- 添加一个图标的组件 --&gt; &lt;font-awesome-icon name=\"user\"&gt;&lt;/font-awesome-icon&gt; Your Profile&lt;/navigation-link&gt; 如果在navigation-link组件的定义中没有包含slot标签，那么该组件标签起始和结束之前的任何内容都会被丢弃。 后备内容 对于一个插槽来说，后备内容是在组件被使用时使用者并未为插槽提供任何内容时显示的内容，可以被称为插槽默认内容。比如定义一个submit-buton组件， 12345&lt;button type=\"submit\"&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 默认情况下如果我们在引用这个组件时，直接像下面这样使用， 123&lt;submit-button&gt;&lt;/submit-button&gt; 会被渲染为， 12345&lt;button type=\"submit\"&gt; Submit&lt;/button&gt; 当提供内容的时候， 12345&lt;submit-button&gt; Save&lt;/submit-button&gt; 则这个提供的内容将会被渲染从而取代后备内容： 12345&lt;button type=\"submit\"&gt; Save&lt;/button&gt; 具名插槽 有时候我们需要将多个插槽定义在组件的不同位置，比如下面的base-layout组件， 12345678910111213&lt;div class=\"container\"&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;/footer&gt;&lt;/div&gt; 对于这种情况，我们在定义slot的时候，需要用到一个特殊的属性name， 12345678910111213&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 不带name的slot出口会带有隐含的名字”default”，对于使用了具名插槽的组件，需要配合template元素使用v-slot指令提供插槽名称的方式去提供插槽内容， 12345678910111213141516171819202122232425262728293031&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt;&lt;!-- 下面和上面的方式结果相同，只不过是一个显示的指定了default，另一个使用默认的方式提供默认插槽的内容 --&gt;&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 注意 v-slot 只能添加在一个template标签上 (只有一种例外情况，下文会提到，为默认插槽添加插槽Prop的时候，在组件标签上添加v-slot)，这一点和已经废弃的 slot 特性不同。 编译作用域 有时候你可能会想在插槽中使用一些这个插槽所属组件内部的数据，比如， 12345678910&lt;navigation-link url=\"/profile\"&gt; Clicking here will send you to: &#123;&#123; url &#125;&#125; &lt;!-- 这里的 `url` 会是 undefined，因为 \"/profile\" 是 _传递给_ &lt;navigation-link&gt; 的而不是 在 &lt;navigation-link&gt; 组件*内部*定义的。 --&gt;&lt;/navigation-link&gt; 官方对这个编译作用域的解释有点难以理解，而且也会涉及到之前的后备插槽的内容，所以我有意将后备插槽以及具名插槽提到这部分前面，便于结合这两部分一起解释这个编译作用域。 先说结论，我们使用插槽添加内容时，这部分我们自定义的内容只可以访问和它本身所处同一模板文件的数据作用域，而不可以访问这个插槽所作用的组件内部的数据作用域。而当我们使用后备内容的时候，后备内容是处于在组件内部的模板定义，所以后备内容只可以访问组件内部的数据作用域，不可以访问组件外部的数据作用域，这两者恰好相反。这时候就很好的可以理解官方的一句话了， 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 我们通过下面的例子可以去理解这种情况，在组件child定义四个具名插槽，前两个个具名插槽都的后备内容分别使用内部和外部两个变量，后面两个的插槽都在父级传递访问内部和外部两个值， 12345678910111213141516171819202122232425&lt;!-- 定义下面的内容 --&gt; Vue.component('child', &#123; template: ` &lt;div&gt; &lt;slot&gt;&#123;&#123; innerMsg &#125;&#125;&lt;/slot&gt; &lt;slot name=\"second\"&gt;&#123;&#123; outerMsg &#125;&#125;&lt;/slot&gt; &lt;slot name=\"third\"&gt;&lt;/slot&gt; &lt;slot name=\"forth\"&gt;&lt;/slot&gt; &lt;/div&gt;`, data()&#123; return &#123; innerMsg: \"内部定义的第一个值\", secondInnerMsg: \"内部定义的第二个值\" &#125; &#125; &#125;); new Vue(&#123; el: '#app', data: &#123; outerMsg: '外部定义的一个值', secondOuterMsg: \"外部定义的第二个值\" &#125; &#125;) 以及对应的html模板， 123456789101112&lt;script src=\"https://unpkg.com/vue\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;child&gt; &lt;template v-slot:default&gt;&lt;/template&gt; &lt;template v-slot:second&gt;&lt;/template&gt; &lt;template v-slot:third&gt;&#123;&#123; secondInnerMsg &#125;&#125;&lt;/template&gt; &lt;template v-slot:forth&gt;&#123;&#123; secondOuterMsg &#125;&#125;&lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 渲染结果， 12345678910&lt;div id=\"app\"&gt; &lt;div&gt;内部定义的第一个值 外部定义的第二个值&lt;/div&gt;&lt;/div&gt;&lt;!-- 另外控制有如下的显示， Property or method \"outerMsg\" is not defined on the instance but referenced during render Property or method \"secondInnerMsg\" is not defined on the instance but referenced during render. --&gt; 作用域插槽 从上面的解释我们知道，后备插槽和自定义的插槽具有独立的作用域，互相都无法访问彼此的作用内容。但数据是可以从父组件流向自组件的，也就是说，虽然子组件中不存在对应的数据，但是可以当数据从父组件中传递到子组件后，在后备插槽中也可以获取到了。但是问题是父组件中无法获取到子组件的数据，如果当我们需要在自定义插槽中使用到子组件的数据的时候，这时候需要借助插槽Prop，也就是作用域插槽，借助官方的例子来说明作用域插槽的使用，有一个current-user组件，它的插槽中存在这样一个后备插槽，后备内容显示用户的名， 12345&lt;span&gt; &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt;&lt;/span&gt; 如果正常情况下我们想要它显示用户的姓，但是user是组件内的值，下面的做法肯定是没有作用的， 123&#123;&#123; user.firstName &#125;&#125; 为了让user在父级的插槽内容中可用，我们可以将user作为元素的一个特性绑定上去： 1234567&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt; &#123;&#123; user.lastName &#125;&#125; &lt;/slot&gt;&lt;/span&gt; 在组件内部的插槽处绑定了属性之后，可以给v-slot带上一个值来定义我们提供的插槽prop的名字，插槽prop对象的命名可以随意，没有过多的约束，这里我们将其命名为slotProps，之后可以使用这个插槽prop对象去访问之前绑定在插槽上的prop， 1234567&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 如果被提供的内容只有默认插槽的时候，可以直接将插槽prop对象的命名放到组件的标签上， 1234567891011 &lt;current-user v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/current-user&gt;&lt;!-- 由于是默认模板，还可以简写为 --&gt; &lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/current-user&gt; 上面简写的方式仅仅可用于仅存在默认插槽的情况，不可以和具名插槽混用，因为每个插槽都有自己独立的Prop对象，这样会导致插槽Prop作用域不明确，如果存在多个插槽的情况，应该使用完整的基于template标签的语法： 1234567891011&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;template v-slot:other=\"otherSlotProps\"&gt; ... &lt;/template&gt;&lt;/current-user&gt; 作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里，在环境支持的情况下(单文件组件或现代浏览器)，另一种获取插槽prop对象的方式是对其进行解构赋值， 123456789101112131415&lt;current-user v-slot=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt;&lt;!-- 使用es6结构赋值对prop进行重命名 --&gt;&lt;current-user v-slot=\"&#123; user: person &#125;\"&gt; &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt;&lt;!-- 在组件内部值不存在的时候，使用结构赋值传递一个默认值 --&gt;&lt;current-user v-slot=\"&#123; user = &#123; firstName: 'Guest' &#125; &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 动态插槽名 在2.6.0+中，可以在v-slot上使用动态指令参数，定义动态的插槽名， 1234567&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt; 具名插槽的缩写 和v-on以及v-bind一样，v-slot也有缩写，即把参数之前的所有内容(v-slot:)替换为字符#。例如v-slot:head，可以被重写为#header， 1234567891011121314&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 该缩写只其在有参数的时候才可用， 1234567891011&lt;!-- 这样会触发一个警告，且这样的语法是无效的 --&gt;&lt;current-user #=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt;&lt;!-- 正确的写法为: --&gt;&lt;current-user #default=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 废弃的语法 前文提过，v-slot是在vue2.6+被支持的语法，之前的语法可以去参照官方文档。 动态组件 &amp; 异步组件 有时候，我们可能在一个元素上根据条件显示不同的组件，这时候我们可能会想要使用v-if去根据数据的不同动态渲染不同的组件。除此之外，同时vue还提供了动态组件去实现这个需求，一个经典的案例如下， 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 已经注册的组件 --&gt;Vue.component('tab-home', &#123; template: '&lt;div&gt;Home component&lt;/div&gt;'&#125;)Vue.component('tab-posts', &#123; template: '&lt;div&gt;Posts component&lt;/div&gt;'&#125;)Vue.component('tab-archive', &#123; template: '&lt;div&gt;Archive component&lt;/div&gt;'&#125;)&lt;div id=\"dynamic-component-demo\" class=\"demo\"&gt; &lt;button v-for=\"tab in tabs\" v-bind:key=\"tab.name\" v-bind:class=\"['tab-button', &#123; active: currentTab.name === tab.name &#125;]\" v-on:click=\"currentTab = tab\" &gt;&#123;&#123; tab.name &#125;&#125;&lt;/button&gt; &lt;component v-bind:is=\"currentTab.component\" class=\"tab\" &gt;&lt;/component&gt;&lt;/div&gt;&lt;!-- vue根组件 --&gt;new Vue(&#123; el: '#dynamic-component-demo', data: &#123; currentTab: 'Home', tabs: ['Home', 'Posts', 'Archive'] &#125;, computed: &#123; currentTabComponent: function () &#123; return 'tab-' + this.currentTab.toLowerCase() &#125; &#125;&#125;) 通过在这个特殊的component标签上添加is属性，我们实现了在一个元素上动态渲染不同组件的功能。这里的currentTabComponent不仅是可以指向已经注册组件的名称，还可以指向一个组件的选项对象，另一种使用例子可以看这里。 从上面我们得知我们可以使用动态组件根据条件在同一个位置渲染不同的组件，但是在不同的组件间进行切换的时候会导致这个组件会被重新渲染，这样在之前的页面进行的一些修改将不会被保留下来。要保留之前组件的状态的，可以使用vue提供的keep-alive元素， 123456&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 使用例子可以看这里。 在大型应用中，我们可能需要将应用分割成一些小的块，并且只有在需要的时候才从服务器中加载，而不是一次将所有需要的内容都加载下来。而通过这种方式进行条件加载的组件被称为异步组件，vue通过允许你使用一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义，且vue只有在这个组件需要被渲染的时候才发触发这个工厂函数的执行，并将结果缓存起来提供到接下来的重渲染， 12345678910Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 但这种编写在vue的方式并不实用，因为我们依然没有减少下载js代码的体积，并让代码的维护性和重构性变的很不友好，所以一般需要配合webpack的code-splitting功能进行一起使用， 12345678Vue.component('async-webpack-example', function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require(['./my-async-component'], resolve)&#125;) 在上述情况下，你也使用返回一个Promise的方式去异步加载这个组件， 123456789101112131415&lt;!-- 全局注册 --&gt;Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component'))&lt;!-- 局部注册 --&gt;new Vue(&#123; // ... components: &#123; 'my-component': () =&gt; import('./my-async-component') &#125;&#125;) 在vue 2.3 +中，加载异步组件的时候，vue支持返回一个包含如下格式的对象去处理在加载过程中组件显示的内容，(如果你希望在Vue-Router中使用下面的语法的话，需要vue-router 2.4 + ) 123456789101112131415const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;) 处理边界情况访问元素 &amp; 组件 在大多数情况下，在一个Vue应用中是不需要直接操作DOM的，但是对于一些情况则不是这样，比如当我们引入一个三方组件的时候，这时候很有可能需要直接操作DOM去达到业务需求。 访问根实例 在每个new Vue实例的组件中，其根实例可以通过$root属性进行访问。比如在下面的例子中， 123456789101112131415161718192021222324252627282930313233// Vue 根实例new Vue(&#123; data: &#123; foo: 1 &#125;, computed: &#123; bar: function () &#123; /* ... */ &#125; &#125;, methods: &#123; baz: function () &#123; /* ... */ &#125; &#125;&#125;);&lt;!-- 通过$root，所有的子组件都可以将这个实例当作一个全局的store来使用 --&gt;// 获取根组件的数据this.$root.foo// 写入根组件的数据this.$root.foo = 2// 访问根组件的计算属性this.$root.bar// 调用根组件的方法this.$root.baz()&lt;!-- 对于 demo 或非常小型的有少量组件的应用来说这是很方便的。 不过这个模式扩展到中大型应用来说就不然了。 因此在绝大多数情况下，我们强烈推荐使用 Vuex 来管理应用的状态。 --&gt; 访问父级组件实例 和$root类似，$parent属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。(将数据传入自组件的方式达到自组件调用父组件方法或修改属性的方式容易让应用变的难以被理解，并且prop的作用应该是父组件需要传递到子组件的初始数据，而不是用于父子组件间的互相通讯。其实即便是通过$root的方式，也会容易使应用很难被理解，但是这种方式相对来说是要优于使用Prop的方式。) 12345678910111213141516171819202122232425&lt;google-map&gt; &lt;google-map-marker v-bind:places=\"vueConfCities\"&gt;&lt;/google-map-marker&gt;&lt;/google-map&gt;&lt;!-- 在子组件调用父组件方法，并传递一个方法引用在父组件的上下文中被调用 --&gt;Vue.component('google-map-marker', &#123; props: ['places'], created: function () &#123; var vm = this vm.$parent.getMap(function (map) &#123; vm.places.forEach(function (place) &#123; new google.maps.Marker(&#123; position: place.position, map: map &#125;) &#125;) &#125;) &#125;, render (h) &#123; return null &#125;&#125;) 访问子组件实例或子元素 尽管存在prop和事件，有的时候你仍可能需要在JavaScript里直接访问一个子组件。为了达到这个目的，你可以通过ref特性为这个子组件赋予一个ID引用。ref被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的$refs对象上。例如： 123&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; 现在在你已经定义了这个ref的组件里，你可以使用访问子组件实例： 123this.$refs.usernameInput 同样在我们的这个base-input子组件中，也可以对组成它的基本元素加上ref属性。如果在普通的DOM元素上使用ref，那么这个引用指向的就是DOM元素。如果用在子组件上，引用就指向组件实例： 12345678910&lt;!-- 在base-input的模板DOM元素上添加1 --&gt;&lt;input ref=\"input\"&gt;&lt;!-- `vm.$refs.p` 是一个DOM对象 --&gt;&lt;p ref=\"p\"&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` 是一个组件实例 --&gt;&lt;child-component ref=\"child\"&gt;&lt;/child-component&gt; $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。关于ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 依赖注入 前面我们已经提到了父组件和子组件互相持有引用的方式，这类场景在cs的应用程序中很常见，在cs程序的开发中，经常使用一些依赖注入框架解决这类问题，比如在Android中就有Dagger等框架。除此之外，在Web服务端也有此类的需求，在后端经常会出现业务之间的交叉，为了减少代码之间的耦合度，也会使用一些依赖注入框架，使用比较多的应该就是Spring IOC了。看来vue也是仿照此类模式的实现，我们来看看Vue中的依赖注入的使用方式，在之前的例子中，假设父组件和子组件之间又需要加入一个中间组件， 1234567&lt;google-map&gt; &lt;google-map-region v-bind:shape=\"cityBoundaries\"&gt; &lt;google-map-markers v-bind:places=\"iceCreamShops\"&gt;&lt;/google-map-markers&gt; &lt;/google-map-region&gt;&lt;/google-map&gt; 由于出现了google-map-region这个组件，并且在这个组件里，所有 的后代都需要访问一个 getMap 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 $parent 属性无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。 provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 内部的 getMap 方法： 1234567provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125; 然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性： 123inject: ['getMap'] 相比$parent来说，这个用法可以让我们在任意后代组件中访问getMap，而不需要在每个子组件间中大量的使用$parent。并且这种方式不需要担心我们可能会改变/移除一些子组件依赖的东西，在对原有逻辑进行很小的改动的情况下调用父组件的方式和属性。 然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像Vuex这样真正的状态管理方案了。 程序化的监听器 我们已经知道可以使用v-on监听$emit发出的事件，但是有时候我们想要在程序中动态的添加监听器，这时候就可以: 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 如果你需要用的一个三方组件，并在组件挂载的时候进行创建，组件销毁的时候同时对这个三方组件进行销毁，你很有可能编写下面的代码， 12345678910111213141516// 一次性将这个日期选择器附加到一个输入框上// 它会被挂载到 DOM 上。mounted: function () &#123; // Pikaday 是一个第三方日期选择器的库 this.picker = new Pikaday(&#123; field: this.$refs.input, format: 'YYYY-MM-DD' &#125;)&#125;,// 在组件被销毁之前，// 也销毁这个日期选择器。beforeDestroy: function () &#123; this.picker.destroy()&#125; 但是这样的方式会使得组件实例持有三方组件的引用，但其实理论上组件实例是没有必要去持有这样的一个引用，这样的增加组件实例的属性的做法显得有些多余。第二个问题是我们的建立代码和清理代码分离，这样如果之后我们需要清理这个三方组件就需要在组件中清理所有销毁的相关内容。 为了解决上面的两个问题，你应该通过一个程序化的侦听器解决这两个问题： 123456789101112mounted: function () &#123; var picker = new Pikaday(&#123; field: this.$refs.input, format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;)&#125; 这样，只需要在组件销毁的时候，$emit一个hook:beforeDestroy事件就可以清理这个三方组件了，甚至可以将它们包裹在一个方法里，即使重复引用多个三方组件，也可以一次清理干净， 123456789101112131415161718mounted: function () &#123; this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput')&#125;,methods: &#123; attachDatepicker: function (refName) &#123; var picker = new Pikaday(&#123; field: this.$refs[refName], format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;) &#125;&#125; 这里需要理解清楚一点，当我们对同一个事件绑定多个处理函数时，在低版本的vue中是不支持使用v-on的数组形式的，并且我们也不可以在组件的标签上定义重复的v-on属性，所以这时候可以使用$on或者$once这样的方式动态添加多个监听器，这样所有的监听器都可以得到添加和执行，需要搞清楚的一个概念是一个事件可以有多个不同的监听器的，执行顺序是先添加先被执行。 注意 Vue 的事件系统不同于浏览器的 EventTarget API。尽管它们工作起来是相似的，但是 $emit、$on, 和 $off 并不是 dispatchEvent、addEventListener 和 removeEventListener 的别名。 循环引用递归组件 组件是可以在它们自己的模板中调用自身的。不过它们只能通过 name 选项来做这件事： 123456789name: 'unique-name-of-my-component'&lt;!-- 当你使用 Vue.component 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 name 选项。 --&gt;Vue.component('unique-name-of-my-component', &#123; // ...&#125;) 虽然递归组件看上去很实用，但是稍有不慎，就有可能导致一个无限循环， 1234name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' 类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 false 的 v-if)。 组件之间的循环引用 假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 组件，模板是这样的： 123456&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=\"folder.children\"/&gt;&lt;/p&gt; 组件， 12345678&lt;ul&gt; &lt;li v-for=\"child in children\"&gt; &lt;tree-folder v-if=\"child.children\" :folder=\"child\"/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代和祖先——一个悖论！当通过 Vue.component 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。然而，如果你使用一个模块系统依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误： Failed to mount component: template or render function not defined. 为了解释这里发生了什么，我们先把两个组件称为A和B。模块系统发现它需要A，但是首先A依赖B，但是B又依赖A，但是A又依赖B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A 反正是需要B的，但是我们不需要先解析B。” 在我们的例子中，把 组件设为了那个点。我们知道那个产生悖论的子组件是 组件，所以我们会等到生命周期钩子 beforeCreate 时去注册它： 123456789101112beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default&#125;&lt;!-- 或者，在本地组件注册时候，你可以使用 webpack 的异步 import： --&gt;components: &#123; TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')&#125;&lt;!-- 这样问题就解决了！ --&gt; 控制更新强制更新 你可能还没有留意到数组或对象的变更检测注意事项，或者你可能依赖了一个未被Vue的响应式系统追踪的状态。 然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。比如Vue就没法检测对Map的追踪，不过这个问题在3.0版本得到添加。 通过 v-once 创建低开销的静态组件 渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来，就像这样：(虽然响应式很好用，但也要使用在适当的地方哦) 12345678910Vue.component('terms-of-service', &#123; template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `&#125;) 再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。 小结 这篇在十月份就开始写了，但是一直到十一月差不多中旬才发出来，效率实在是底下，虽然其中有很多其它的事情造成了一些拖延，但是这个速度还是不能被接受。这段时间差不多将近一个半月，陆陆续续抽时间将vue-router、vuex、vue的文档刷了一遍，vue还有小部分没有看，算是对之前的查漏补缺吧，也知道了很多之前没有刻意去了解过的一些细节。接下来的计划大概是先把vue剩下的内容刷完，然后再去研究webpack的文档，webpack实在是太重要了，简直就是前端项目的基石。也不知道等自己刷完这两个内容要多久，不过看了下接下来的开发计划，自己应该是挺闲的。应该可以在年前将这些都搞定。 再接下来的计划可能就很明确了，刷文档的目的当然还是为了开发做铺垫，很多人可能会说我不刷文档也可以愉快的开发呀。但是个人觉得这种方式对于职业来说太不靠谱，很多东西都理解的不透彻，在需求当头的时候就看能用就用了，也不考虑这样做的一些后果，或者说弊端。这对工程来说就是不负责的表现，自己也看了太多这种例子，对这种行为个人是有一些鄙视成分在里面的，虽然人都有一个成长的过程，但我觉得这是习惯问题，或者说态度问题。看多了这种粗制滥造的代码之后只能说，不可能要求每个人做到完美，对自己要求严格就行，不让自己难受就好了。 不知道还会不会写技术博客，自己有点儿动摇，因为有道笔记对我来说明显比md形式的博客更加方便，写完这篇之后自己确实有些动摇了，因为这对自己来说就像是一些笔记，而笔记是只适合个人翻阅的。 em…罗马不是一天建成的，早点休息吧。","categories":[{"name":"UI","slug":"UI","permalink":"http://swcheng.com/categories/UI/"},{"name":"VUE","slug":"UI/VUE","permalink":"http://swcheng.com/categories/UI/VUE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"Vue基础 - Class和Style绑定","slug":"Vue基础-Class和Style绑定","date":"2019-10-28T02:00:00.000Z","updated":"2019-10-28T05:23:25.106Z","comments":true,"path":"2019/10/28/Vue基础-Class和Style绑定/","link":"","permalink":"http://swcheng.com/2019/10/28/Vue基础-Class和Style绑定/","excerpt":"在开发中我们不可避免的要动态的改变一个元素的样式，有时候是为了响应用户操作，有时候是根据数据的不同显示不同的样式等。这些时候我们的样式不可以进行硬编码，在正常情况下我们需要手动编写JS去实现这个功能，但是在Vue组件中，可以使用数据绑定一样的方式为组件的属性进行赋值达到动态修改组件样式的目的，由于Vue强大的响应式功能，我们可以很方便的修改组件的class和style属性。","text":"在开发中我们不可避免的要动态的改变一个元素的样式，有时候是为了响应用户操作，有时候是根据数据的不同显示不同的样式等。这些时候我们的样式不可以进行硬编码，在正常情况下我们需要手动编写JS去实现这个功能，但是在Vue组件中，可以使用数据绑定一样的方式为组件的属性进行赋值达到动态修改组件样式的目的，由于Vue强大的响应式功能，我们可以很方便的修改组件的class和style属性。 Vue对class和style两个属性做了特别的增强，一般的属性的值只能为js计算结果的字符串，但class和style除了字符串外，还可以是对象或者数组： class绑定使用对象的方式 为class属性添加一个对象， 1 &lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 在使用对象表达一个组件的class的时候，对象的属性表示class的值，而该属性的值isActive是否为一个真值，即true或false，如果不是true或false则会被强制转化为true或false值。当其为true的时候表示改组件有这个属性表示的class，否则没有，所以你可以通过在这个对象中添加多个属性达到控制组件class的目的。比如使用下面的方式： 123&lt;div v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 此外，v-bind:class属性还可以和普通的class属性共存，比如有下面的例子： 1234&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 如果有以下data， 1234data: &#123; isActive: true, hasError: false&#125; 结果会被渲染为， 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 当isActive或者hasError的值变化时，class列表将相应地更新。例如，如果hasError的值为true，class列表将变为”static active text-danger”。当然这里前提是isActive和hasError需要满足响应式的前提，由于js的限制，vue无法对对象属性的增加和删除进行响应，也没法对数组的非变异方法进行响应。 使用数组的方式 我们可以把一个数组传给 v-bind:class， 123456&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;&lt;/div&gt;data: &#123; errorClass: 'text-danger', isActive: true&#125; 与对象的渲染方式不同，使用数组会判断在数组中的变量类型，如果变量的值的类型为一个对象，那么它会像传递对象的方式去处理这个变量，如果这个变量的值的类型为一个字符串，那么会将其代表的字符串的值作为组件的class属性， 1&lt;div class=\"active text-danger\"&gt;&lt;/div&gt; 在使用组件的方式的时候，你可以使用三元表达式去控制数组中的成员达到控制组件属性的目的：1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;&lt;/div&gt; 与模版class共存 之前我们已经知道v-bind:class可以与class共存，除此之外，其实v-bind:class以及class都同时可以和组件定义处的属性共存。例如，你声明了下面的组件，123Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) 如果直接添加一些class，1&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; 结果会被渲染为：1&lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; 同样对于v-bind:class也同样适用，1&lt;my-component v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/my-component&gt; 当 isActive 为 truthy[1] 时，HTML 将被渲染成为：1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; style内联样式绑定使用对象的方式 与class绑定有所区别，在内联样式的绑定中，对象的属性和值分别表示css属性的名称和值，需要注意的是，对象属性的值类型必须为字符串而不可以是其它任意类型的值，因为vue无法判断对象属性中的值的单位，所以我们必须使用字符串进行准确的定义。CSS的很多属性都使用横线分割表示，我们在js中对象定义属性的时候无法直接定义短横线分割的属性，虽然可以通过加单引号包含的方式添加这样的属性，但是访问起来也必须通过[]的方式引用，这样未免太不人性化，所以vue提供了驼峰式(camelCase)的方式在对象中定义属性达到定义css属性的方式： 123456&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个样式对象通常更好，这会让模板更清晰：12345678&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 结果会被渲染为:1&lt;div style=\"color: 'red'; fontSize: '13px'\"&gt;&lt;/div&gt; 使用数组的方式 v-bind:style使用数组的方式类似于v-bind:class，可以同时定义多个变量，也可以使用三元表达式，同时根据变量的类型去定义css属性。 自动添加前缀 在v-bind:style使用一些需要自动添加]浏览器引擎前缀的css属性的时候，Vue.js 会自动侦测并添加相应的前缀。 多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：1&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt;&lt;/div&gt; 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。","categories":[{"name":"UI","slug":"UI","permalink":"http://swcheng.com/categories/UI/"},{"name":"VUE","slug":"UI/VUE","permalink":"http://swcheng.com/categories/UI/VUE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"小半，小梦大半","slug":"小半，小梦大半","date":"2019-08-25T08:32:00.000Z","updated":"2019-08-25T13:52:26.689Z","comments":true,"path":"2019/08/25/小半，小梦大半/","link":"","permalink":"http://swcheng.com/2019/08/25/小半，小梦大半/","excerpt":"纵容着 喜欢的 讨厌的 宠溺的 厌倦的 一个个慢慢黯淡 不明白 残存的 没用的 多余的 不必的 破烂也在手紧攥 -陈粒 «小半»","text":"纵容着 喜欢的 讨厌的 宠溺的 厌倦的 一个个慢慢黯淡 不明白 残存的 没用的 多余的 不必的 破烂也在手紧攥 -陈粒 «小半» 不太记得是什么时候第一次听陈粒的歌了，看了看网易云歌单的创建时间2017-08-12，应该那时候是第一次觉得陈粒的歌好听吧~ 但虽然很早建立了陈粒的歌单，但她的歌大多刚开始听的时候确实不是特别喜欢，所以除了其中的某几首之外其它的歌基本不太听。可能有些歌就是需要特别的情景下才适合去听，小半这首歌刚开始只是觉得旋律比较轻快，直到某一天，在从地铁站回学校的路上，小半这首歌意外的播放在耳机里。当时就被这篇博客开头的两句给完全捕获了，喜欢的讨厌的宠溺的厌倦的都慢慢黯淡，简直就是直戳心窝。 当时自己就在心中给陈粒贴上了一个”哲学粒”的标签，陈粒的词让我不禁想起兰亭集序中的及其所之既倦，情随事迁，感慨系之矣，有异曲同工之妙的感觉。听小半的时候，发现原来自己曾经沉溺过的事情如歌词所述渐渐变的黯淡，再也无法在心里感受到当时那种惊奇，即使有时候想要再去体会从前那种沉溺的感觉，但发现什么都感受不到，这时候才发现一切的喜欢都是和当时的环境和认知紧密关联的，同时也认识到，过去也只适合用来怀念，不适合再去体会。 因为小半，陆陆续续又去认真的听了陈粒的很多作品，发现她作品中的词都或多或少的带有某些哲学的味道，但从她的歌声中听到的总是云淡风轻的感觉，这种感觉需要很认真去体会，不像很多歌曲的编曲会刻意在感情的爆发点表现的特别强烈。 欣赏陈粒的歌曲可能真的需要一个特别的情景吧，比如最近自己在听的芳草地中的歌词: 等我的脾气 都成为道理 以及 无常留给我浪费力气 等长夜付真心 在安静的芳草地 都是用很轻松的节奏去表现，但仔细想都能感受到作词人当时那种情景和内心的强烈感受。还有无所求必满载而归里的: 无所求也求不得 当我昏昏欲睡 摇摇欲坠 却学会 放下错与对 是与非 无所求必满载而归 这几句也颇有些哲学的味道，看似是放下了自己追求的东西，放下了自己的执念。但是从另外一个角度来看，得到和失去本身的区别并不大，当你顺利得到某个东西之后，你会很快习惯这个既定的事实，慢慢这个你曾经觉得很重要的东西也会变的稀松平常。而即使经过自身的努力，自己想要的东西并没有遂愿，也并不觉得可惜，因为在这个过程中你已经体会到了太多东西，这些宝贵的经历对你而言其实已经是满载而归了。故而当我们用无所求的心态去做一件事的时候，也就是现在所说的佛系的心态，无论结果如何，我们最终一定会满载而归而不会觉得失落。 em…除了上面提到的几首，还有一首桥豆麻袋也是一首节奏很轻快，但很有意思的一首歌，比如其中的: 爬呀爬呀苦了自己 长路漫漫无目的 以及 请再看一下 还有诈尸的蚯蚓 这两句很好理解，不要为了目的而丢失掉寻找乐趣的心态，因为快乐是最难得的，而目的达成只是占快乐很小的一部分。个人体会而言，很多时候自己被一个目的驱使下去做一些事情，无论是主动或是被动，总容易陷入不断赶路的怪圈中，这大多是因为对结果的担忧使自己变得焦虑和不安，在焦虑和不安的驱使下我们不断努力向前赶路，忽略了仔细去感受沿途的快乐，此时占据大脑中的只有未完成的任务，以及如何尽快完成剩下任务。如果长时间处于这种模式下，整个人精神状态越来越差，对做的事也会开始感到麻木，陷入一个没有尽头的死循环，直到自己承载不了的那一天这些积累的负面因素会彻底爆发。 目的地真的有那么重要吗？其实真的未必，目的应该更多是提供给我们一个方向，而不是约束。当真正完成目标的那一刻，一切并未发生任何改变，生活还是本来的样子，工作任务还是会断断续续来临。一个目标达成后，就如爬上一座山，就像曾经某人说过的，我也不太记得到底是谁说的，”海那边还是海，山那边还是山”。这时候你应该问问自己这个过程中是否真的快乐，或只是在打发生命无聊的时光而已。 em…长路漫漫，任何人或事都可以被取代，学着多让自己开心一点吧。 还有很多很棒的歌，比如历历万乡的开头两句就很惊艳，怪情歌的比喻也是让人哭笑不得，少有的像祝星一样直抒情情感的调调，总之很棒的一个歌手，虽然还是有很多歌我不喜欢……不过陈粒这个Artist自己是比较佩服的，在环境如此恶劣的情况下这样的歌手能出现在大众的视线里实在是太难了。 真希望有机会可以去感受现场，19-8-25，好想听燕姿和粒粒的现场aaaaaaaaaaaaaa!!!!!!!!!!!!!!","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"Keep relax, Keep curious, Keep ur fire","slug":"Keep relax, Keep curious, Keep ur fire","date":"2019-06-30T15:59:00.000Z","updated":"2019-07-01T14:27:55.497Z","comments":true,"path":"2019/06/30/Keep relax, Keep curious, Keep ur fire/","link":"","permalink":"http://swcheng.com/2019/06/30/Keep relax, Keep curious, Keep ur fire/","excerpt":"已经离开学校两周了，搬到一个新地方很多事情都需要去做，比如熟悉周围环境，打扫新住处的卫生，购置很多平时需要用到的东西等。刚好下周因为项目要发布一版，所以这周就特别的忙，然后任务也比较赶，自己也感到有些累。突然发现已经很长时间没有更新过博客了，其实也不知道写点什么，就随便写点好了。","text":"已经离开学校两周了，搬到一个新地方很多事情都需要去做，比如熟悉周围环境，打扫新住处的卫生，购置很多平时需要用到的东西等。刚好下周因为项目要发布一版，所以这周就特别的忙，然后任务也比较赶，自己也感到有些累。突然发现已经很长时间没有更新过博客了，其实也不知道写点什么，就随便写点好了。 除了工作之外，寻找自己的兴趣真的很重要。这个兴趣或许和工作有关，或许无关，这都没有关系，关键是一定要去找到一些自己感兴趣的事情去让自己思考不一样的东西，与工作无关的东西。看到叔本华的一句话很触动自己，”长时间习惯于同样的感觉印象，会使我们的智力疲劳和迟钝”。当时就明白了自己长时间接触代码，自然就会产生抵触的心理，我一直认为这是自己的原因，以为自己的努力不够，总是想多花些时间去学习不知道的知识。但最终获得的效果，让自己开始怀疑自己是否适合继续从事目前的职业，也有了之前去面试销售的行为。 又想起老师之前和自己聊过的这个话题，有太多事情可以去做了，没有必要和自己过不去，对自己好一点。人生旅途中的风景不是比目的地更重要吗，谁在乎目的地在哪儿，好好享受旅途上的风景不是重要的多吗？想想这句话真的说的挺好的，但是总觉得替所谓的未来考虑或者做准备已经成为了自己的习惯，想要一时就改变实在是太难了。想想为未来做计划真的有那么重要吗？即使你目前认为未来是什么样的，并为之去努力，但当你努力的为未来做准备的时候，到了那天却发现情况又变的截然不同了，因为事务总是处于不断的变化之中的。并不是努力无用，只是需要用一种更好的方式去努力，明白自己的缺点是什么，抓住事务的规律，认准一个方向，再去努力，而不是无意义的紧绷神经。 总而言之，方向比努力更重要。这是自己犯过很多次的错误，总是被好奇心的带动去了解一些东西，觉得自己不明白，用一句成语总结来说就是不明觉厉。但是我们的精力有限，没有办法去将每个东西动弄明白，研究透彻。而且我们也不需要去这么做，因为从大局观的角度来看待问题，不是那件事情我们做不了，而是我们需要将精力放在更加重要的事情上来。站在一个更高的角度看待问题，就是即使我们每件事情都去做，其实我们在有限的时间里可以做到的是大部分人都可以去实现的工作，虽然这种工作确实需要花费一些时间成本去做，但我们最终在整个整体中完成的不过是一些边角料的工作。看上去面面俱到，实则缺乏特点。最终做的不过是一些堆积木的工作而已，而不是去设计核心组件。 这是自己不知道犯过多少次的错误，刚开始这些工作算是有些挑战性，但重复的多了，也就真正成为了”大自然的搬运工”。所以，要做一个有梦想的搬运工。正如拿破仑所说的，不想当将军的士兵不是好士兵。没有想法的搬运工也不是一个好的搬运工。其实自己很了解自己薄弱点在哪儿，我也是时候好好静下心在数据结构和算法方面多去研究研究，除此之外，多线程这一块也是自己很惨的地方，自己看文档的习惯也不太好，很多东西都无法做到全部理解，总是看完似懂非懂，觉得可以操作起来就行了。从来不会去回顾自己的一些思路，一些没弄明白的地方。 虽然自己现在有很多地方动不懂，但就像孔子说的，”生也有涯而知也无涯”。学习不过是生活的部分而已，或者说是生命里的一部分，而不是全部，用心去享受生活中很多美好的东西，也不忘用力去追逐自己的梦想，该执着的不妥协，该放弃的不踟躇，不盲目追逐和羡慕，照顾好自己和家人，以及那些对我而言很重要的人，还有，别太认真了，多皮一点，多开心一点。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"近期小结","slug":"近期小结","date":"2019-05-25T13:32:00.000Z","updated":"2019-05-25T16:18:57.184Z","comments":true,"path":"2019/05/25/近期小结/","link":"","permalink":"http://swcheng.com/2019/05/25/近期小结/","excerpt":"呼~开学来这段时间真是忙的够呛。好在学校的事情基本差不多都结束了，除了后续还有一个遗留的短学期需要再处理一下。回想一下自己一边找工作一边写毕业设计的过程，前后差不多历经12周的时间，细细数来也差不多将近三个月的时间了，终于有个可以喘息的时间了~","text":"呼~开学来这段时间真是忙的够呛。好在学校的事情基本差不多都结束了，除了后续还有一个遗留的短学期需要再处理一下。回想一下自己一边找工作一边写毕业设计的过程，前后差不多历经12周的时间，细细数来也差不多将近三个月的时间了，终于有个可以喘息的时间了~ 难受的是，自己又被自己的话给打脸了，什么周六日绝对不学习要找个地方出去逛，什么一定要找时间练习滑板之类的，算了算了，我还是忘了自己说过的话比较合适，因为真的没几件是完成的，嗯，没错，打脸对于我来说就是日常操作。 最近换了台机器，因为上个兄弟真的到了退役的时候，自己也弄不懂为什么有时候无法识别到机械硬盘但开机几次之后又可以了，很奇怪真的，然后第一次出现这个问题的时候我没太在意，以为只是一次偶然。直到第二次又出现了这个问题的时候，想到后续万一毕设答辩前自己的电脑挂了这种可能，无奈之下只好现将代码都同步到github上去，然后换个兄弟将所有开发环境又搭了一次，这整整花了自己一天的时间才将所有的环境都部署好。上网查了一下机械硬盘会挂掉的原因，有的人说是因为接触不良，但自己不太懂硬件的一些东西，自己去拆机维修太冒险了，没必要去冒这种风险，但拿去维修的话又不知道要什么时候才能修好，而且自己平时上班也要用，在学校搞毕设也要用，这个尴尬的时候确实不适合拿去维修，索性就更换了自己的装备。 开始还在纠结自己要去买什么机子好，最后还是选择了神舟，因为我对配置的要求要胜于对外观的要求，所以配置太低的基本不在自己的考虑范围内。加上最近英伟达出了16系的显卡，所以我就瞄准了搭配1660TI显卡的本子，开始考虑的是雷神系列的本子，但实在是太贵了，i7九代配上这个显卡价格就到了九千了，但反之看神舟的价格还不到七千，虽然神舟丑是丑了点，做工当然也没雷神好，但是我觉得一个游戏本最重要的一点是它的散热，如果散热不好的话外观再好看配置再好也是白搭，之前自己就深受华硕zen系列之苦，明明配置不错却使用起来像是个瓜皮，真的受不了，为了外观都不考虑散热口的，把散热口放在屏幕的下面，还在网上鼓吹自己的散热如何如何，哎，想想自己当年是真的弱智，反正以后是不可能再买华硕的本了。 虽然说神舟的售后据说不怎么样，但是我估计售后还是有的，相对一线大厂如Dell、Asus、Hp等就会差很多。但电脑硬件坏这种情况我觉得这种事情还是比较少发生的，一般的软件问题自己应该也可以搞定，所以想想自己一定程度上可以忽略这个问题，再说鱼和熊掌不可兼得嘛，适合自己的总是最好的，个人觉得神舟从各方面来说还是比较适合自己的。经过这段时间的使用，自己对神舟的这款本子还是比较满意的，除了它的镜面屏让我有点难受之外，其它方面基本没有什么缺点。为了在原有的基础上去提升它的性能表现，前几天自己还特地买了一根8G的内存条搭载上去，自己发现加了内存条之后从单通道变成双通道之后简直速度要飞起，又想起自己买的第一个本，拆开一看发现只有一个内存槽就算了，居然为了凑8G还内置了一个4G的内存条，真TM的是奸若磐石呀，这可真不是白喊出来的，此时此刻我想再喊一遍，再买华硕我是狗！！！ 估计以后自己不会怎么使用老兄弟了，有点伤感，毕竟自己是一个怀旧的人。等资金充足了找个师傅修修老兄弟，说不定哪天自己挖矿什么的或者做测试什么还需要两台计算机，毕竟这东西用久了也不想当做二手卖出去，总是有些感情的，这可是承载了自己四年的回忆啊。 还是小结一下最近的事情吧，扯着扯着就说到笔记本上了。其实就是一通瞎忙，还是自找的，给自己目标设定过高，结果将自己累吐血。主要还是自己对自己过于自信，所以使用很多自己不熟悉的技术去做开发，事实上没什么不可以，就是被逼的用尽所有时间去学习需要的知识。这一顿搞完差不多真的快累垮了，近几天自己就只想睡觉什么其他的事情都不想做，累到荼蘼。想想忙完学校的事之后公司又会有一堆事接踵而来，公司的技术栈自己完全要重学，虽然我觉得对于自己来说没有什么特别大的问题，但还是想放松一段时间再投入到下一阶段中，之前自己就曾经犯过同样的错误，为了按时完成项目不断的push自己去学习然后不仅效率变得极低，而且整个人都不好了，甚至怀疑自己是否还存在。所以学会放松是非常重要的一件事情，效率高的时候看一个东西很快就知道该怎么做了，如果长期处在一个状态会变得极其低效，本来大部分的东西就不需要花费那么多时间，基本保持专注力几天都可以学到一些核心内容。 莎士比亚说，思虑过多就失去了做人的乐趣，这句话真是说到自己的内心最真切的感受，但代码的思维跟的多了就会不自觉的对大部分事情都从思考的角度出发，然后发现一切事物就变得没有了趣味可言，这真的变成了一种恶性循环。昨天刚看了一部电影非分熟女，电影里说的一句话很是打动我，很多事情要学会用心去感受，而不要用头脑去思考。看来自我调节是一门真正需要必修的课，而我这门课明显是不合格的，慢慢去学吧，时刻提醒自己要学会放松自己的意识，用心去感受接触到的事物，因为自己一用头脑思考就会变得十分冷漠无情，和一个机器人无异了。 em…可能这是自己最想总结的内容吧，也是因为独在异乡，对这座城市没有归属感，而且这个地方没有真正意义上的朋友，这两个因素也是导致自己时常觉得生活无味的原因。记得老师曾给我建议，就是没必要对朋友那么苛求，可以把不同的朋友分成不同的类别，比如这个朋友可以一起干这个，而那个朋友可以一起干其他的事情，我觉得这对于自己很难做到，可能自己的内心是比较高冷的吧，对一些人了解之后感到他们的无趣就基本可以判断它们对于一些事情会做什么样的反应，而自己也不喜欢去刻意附和自己厌恶的东西。自己也不喜欢去隐藏自己的情绪，所以说注定自己做不到老师提供的建议。 em…还是想说那句话，很孤独但很爽，不用面对这些虚伪的面孔，起码让我感受到这才是属于自己的自由，如果为此付出的代价很昂贵的话，I will say, I choose my fate.","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"EXPERIENCE","slug":"EXPERIENCE","permalink":"http://swcheng.com/tags/EXPERIENCE/"}]},{"title":"Vue基础-事件处理和表单数据绑定","slug":"Vue基础-事件处理和表单数据绑定","date":"2019-04-21T10:56:00.000Z","updated":"2019-10-28T01:59:17.216Z","comments":true,"path":"2019/04/21/Vue基础-事件处理和表单数据绑定/","link":"","permalink":"http://swcheng.com/2019/04/21/Vue基础-事件处理和表单数据绑定/","excerpt":"创建一个vue对象:","text":"创建一个vue对象:1234567891011121314151617181920212223242526272829303132333435363738var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0, message: \"\", multiMessage: \"\", checked: false, checkedNames: [], picked: \"One\", selected: \"A\" &#125;, methods: &#123; greet: function(event)&#123; alert(event) alert(\"Greet from vue\") &#125;, say: function(message)&#123; alert(message) &#125;, warn: function(msg, event)&#123; // 这里我们可以直接调用原生对象event if(event) event.preventDefault() alert(msg) &#125;, doThis: function()&#123; console.log(\"dothis\") &#125;, onSubmit: function()&#123; console.log(\"onSubmit\") &#125;, doThat: function()&#123; console.log(\"dothat\") &#125;, submit: function()&#123; console.log(\"submit\") &#125; &#125;&#125;) 监听事件 使用v-on指令去进行基础事件的监听，在触发事件时进行相应处理:12345&lt;div id=\"example-1\"&gt; &lt;!-- 基本的事件处理 --&gt; &lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt; 这里我们监听的是click的事件，每次点击都会使下面的文字显示增加一次点击的次数，但是一般点击事件不应该直接在html里进行处理，我们应该尽可能的将其写在js代码中。比如:1 &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt; 点击这个按钮则会调用greet方法，这里我们直接绑定的是在vue对象中定义的方法名而不带任何参数，当然也可以选择在这里选择直接调用一个带参数的方法。并且这里兼顾了属性定义监听和使用DOM定义绑定方法对象两种方式。比如:1&lt;button v-on:click=\"say(message)\"&gt;Say&lt;/button&gt; 如果我们需要获取原生的DOM对象，可以使用特殊变量$event将其传递到方法中:123&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt; 对于很多事件，我们很多时候不仅仅是需要一个回调方法，我们很多时候还有其它的操作，对于一些常见的设置，为了方便vue提供了事件修饰符，比如: .stop .prevent .capture .self .once .passive 下面是对这些修饰符的解释。12345678910111213141516171819202122232425262728&lt;!-- 点击事件将只会触发一次 2.1.4 新增 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 阻止单击事件继续传播,相当于调用stopPropogation --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面，相当于阻止了浏览器默认行为，调用了preventDefault() --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 甚至可以只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式，这里捕获的是在capture阶段，而非默认的bubble阶段 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数,相当于在event的回调方法中加了判断 --&gt;&lt;!-- 比如判断this === event.target 决定是否执行代码 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 浏览器滚动事件的默认行为 (即滚动行为) 将会立即触发，为了提升浏览性能，尤其是移动端--&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况,与一般的实现有所区别 2.3.0 新增 --&gt;&lt;!-- 不可以将.prevet与.passive一起用，因为它们本身就是冲突，如果你这样做了，.prevent会被忽略 且同时获得一个警告 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 很多时候我们需要监听特定按钮的键盘事件，那么此时我们可以去使用一些按键修饰符。比如:12&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt; 可以直接将 KeyboardEvent.key暴露的任意有效按键名转换为 kebab-case 来作为修饰符。也可以使用按键码去作为修饰符，这keycode已经被废弃了，所以这里也不涉及到该部分的内容。同时会有一些系统修饰键比如ctrl、alt之类的，如果需要触发该类事件可以使用连续的修饰符。这些系统修饰键有: .ctrl .alt .shift .meta 比如:12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 表单数据绑定 在一个表单中只能包含一些表单元素，常见的表单元素有input、textarea、select等。所谓的表单数据绑定在vue中指的是将vue数据对象与表单元素的输入进行绑定，也就是说无论是vue数据对象的变化或者是表单元素的输入，都会同步修改对方的值。在vue中使用v-model指令去实现这一功能，而v-model指令本质也是通过监听用户的输入事件去更新输入。v-model针对不同的元素的不同属性抛出的不同事件进行数据修改，text 和 textarea 元素使用 value 属性和 input 事件；checkbox 和 radio 使用 checked 属性和 change 事件；select 字段将 value 作为 prop 并将 change 作为事件。 下面是一些基本组件的使用的例子:123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 普通input输入框 --&gt;&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;!-- 多行输入 --&gt;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line;\"&gt;&#123;&#123; multiMessage &#125;&#125;&lt;/p&gt;&lt;textarea v-model=\"multiMessage\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt;&lt;!-- 单个复选框 --&gt;&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;!-- 多个复选框，绑定到同一个数组 --&gt;&lt;div id='example-3'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;!-- 单选按钮 --&gt;&lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt;&lt;label for=\"one\"&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt;&lt;label for=\"two\"&gt;Two&lt;/label&gt;&lt;br&gt;&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;!-- 选择框 --&gt;&lt;select v-model=\"selected\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;","categories":[{"name":"UI","slug":"UI","permalink":"http://swcheng.com/categories/UI/"},{"name":"VUE","slug":"UI/VUE","permalink":"http://swcheng.com/categories/UI/VUE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"Vue基础-条件列表渲染","slug":"Vue基础-条件列表渲染","date":"2019-04-21T06:22:00.000Z","updated":"2019-10-28T01:51:31.013Z","comments":true,"path":"2019/04/21/Vue基础-条件列表渲染/","link":"","permalink":"http://swcheng.com/2019/04/21/Vue基础-条件列表渲染/","excerpt":"创建一个下面的vue对象:","text":"创建一个下面的vue对象:123456789101112131415161718192021222324252627282930313233Vue.component('my-component',&#123; template: '&lt;li&gt;This is a todo&lt;/li&gt;', props: ['item', 'index']&#125;);var app = new Vue(&#123; el: \"#app\", data: &#123; awesome: true, notawesome: true, ok: true, loginType: \"username\", showornot: false, items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ], parentMessgae: \"parent\", forObject: &#123; firstName: \"John\", lastName: \"Sonw\", age: 40 &#125; &#125;, methods: &#123; toggleLoginType: function()&#123; if(this.loginType == \"username\") this.loginType = \"email\" else this.loginType = \"username\" &#125; &#125;&#125;); 条件渲染 使用v-if指令进行条件渲染，当属性值为true的时候显示内容否则不显示。1&lt;p v-if=\"awesome\"&gt;I was rendered by if command&lt;/p&gt; 当然也可以使用else，甚至else-if,但是需要注意的是，这些语句必须书写在一起。1234&lt;p v-if=\"loginType == 'username'\"&gt;Username login&lt;/p&gt;&lt;!-- v-else必须紧跟v-if 或 v-else-if后面，否则不会生效 --&gt;&lt;p v-else-if=\"loginType == 'email'\"&gt;Email login&lt;/p&gt;&lt;p v-else&gt;No, I am the king&lt;/p&gt; 如果想要一次渲染多个元素，可以使用template标签:12345678910&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;h1&gt;Another&lt;/h1&gt; &lt;p&gt;Paragraph 21&lt;/p&gt; &lt;p&gt;Paragraph 22&lt;/p&gt;&lt;/template&gt; 渲染结果:123&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Paragraph 1&lt;/p&gt;&lt;p&gt;Paragraph 2&lt;/p&gt; Vue为了尽可能高效的渲染元素，通常会复用现有元素而不是从头开始渲染，如果你需要vue重头开始渲染元素，那么你需要为它们指定key属性。12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; 使用v-show 如果我们需要经常切换某个元素是否可见，为了效率起见我们应该使用v-show指令而非v-for。因为v-for是惰性的，只有当条件成立的时候才会渲染元素，而v-show则是无论条件是否成立都会一开始就渲染元素。并且v-show每次切换仅仅修改css的display属性，而v-if则会使条件块内的事件监听器和子组件适当地被销毁和重建，这样明显每次切换开销都要大于v-show。v-show的简单使用用例如下。12&lt;!-- 对于一些经常需要改变的元素可以使用v-show，即只改变display的值 --&gt;&lt;h1 v-show=\"showornot\"&gt;我是vshow代表&lt;/h1&gt; 列表渲染 使用v-for指令达到渲染一个列表的目的，并且需要使用item in items形式的语法，你也可以使用of去代替in。比如下面这个例子:1234567891011&lt;ul id=\"example-1\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 或者使用of代替in --&gt;&lt;ul id=\"example-1\"&gt; &lt;li v-for=\"item of items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 渲染结果:1234&lt;ul&gt; &lt;li&gt;Foo&lt;/li&gt; &lt;li&gt;Bar&lt;/li&gt;&lt;/ul&gt; 支持第二个参数作为当前项的索引。甚至你可以在v-for块中访问父级的属性。123&lt;ul&gt; &lt;li v-for=\"(item, index) in items\"&gt;-&#123;&#123;index&#125;&#125; -&#123;&#123;item.message&#125;&#125; &#123;&#123; parentMessgae &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 渲染结果:1234&lt;ul&gt; &lt;li&gt;-0 -Foo parent&lt;/li&gt; &lt;li&gt;-1 -Bar parent&lt;/li&gt;&lt;/ul&gt; 除了数组之外，你也可以使用一个对象作为v-for指令的输入。比如:1234&lt;!-- 除了数组之外，你也可以使用对象去作为一个遍历 --&gt;&lt;p v-for=\"prop in forObject\"&gt; &#123;&#123; prop &#125;&#125;&lt;/p&gt; 渲染结果:123456789&lt;p&gt; John &lt;/p&gt;&lt;p&gt; Sonw &lt;/p&gt;&lt;p&gt; 40 &lt;/p&gt; 与数组一样可以接受多个参数。需要注意的是，第一个位置一定是value，第二个位置一定是key，第三个是index。这与js的语言特性有关，因为其有一个arguments变量，而方法中的参数名只是针对其位置对其进行赋值而已。需要注意的是遍历的顺序是按照Object.keys()的结果，但是可能在不同的js引擎是不一致的。并且与v-if类似，vue会智能的复用组件，所以如果有需要可以在v-for遍历的组件上加上key属性去标识每一个组件提示vue不需要进行复用。123&lt;p v-for=\"(value, key, index) in forObject\" :key=\"index\"&gt; &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125; : &#123;&#123;index&#125;&#125;&lt;/p&gt; 渲染结果:123456789&lt;p&gt; firstName : John : 0 &lt;/p&gt;&lt;p&gt; lastName : Sonw : 1 &lt;/p&gt;&lt;p&gt; age : 40 : 2 &lt;/p&gt; 类似于v-if，你也可以使用template标签去包含一块需要遍历的内容。123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\" role=\"presentation\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 同样，如果我们不想要使用原始数组，我们也可以使用一个计算属性或者调用一个方法做到灵活运用选择。计算属性的使用与普通属性相似，下面是方法的使用:(注意，vue对数组的更新检测会由于js的限制受到对应的限制，具体查阅官方文档列表渲染部分的说明)12345678910data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125;1&lt;li v-for=\"n in even(numbers)\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; 甚至可以直接取整数:123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 渲染结果:11 2 3 4 5 6 7 8 9 10 数组更新检测 那么我们的列表经过渲染之后，在很多场景下可能会需要对其进行修改，这就是vue里所谓的数组更新检测。在vue中，包含一些变异方法和一些非变异方法，所谓的变异方法就是修改了原数组的内容，而非变异则是不会对原数组里的内容进行修改。但是对于vue来说，仅当变异方法的调用将会触发视图的更新。比如:123456789101112&lt;!-- vue包含了一些数组变异方法，通过调用这些方法我们可以更新引用该数组的视图 --&gt; push() pop() shift() // 把数组第一个元素删除掉 unshift() // 在数组第一个位置新增一个元素 splice() // splice(index1, index2, ...) index1表示插入的位置，index2表示删除元素的数目， ... 表示新增的元素 sort() reverse() ， 当然也有一些非变异方法，比如: concat()、filter()、slice()，当然也可以手动去调用这些方法去为数组重新赋值 concat() 拼凑多个数组、filter用于过滤一些不需要的值、slice相当于substring,返回起始和结束之间的索引 --&gt; 如果你需要使用非变异方法达到修改视图的目的，那么你需要将原来的数组指向非变异方法的返回值。123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 由于js的限制，不可以检测通过索引修改数组的一个项以及直接修改数组的长度的变化，为了解决第一种问题，在vue中提供了:123456Vue.set(app.items, indexOfItem, newValue)// 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：vm.$set(vm.items, indexOfItem, newValue)// 或者使用:// Array.prototype.splice,即变异方法app.items.splice(indexOfItem, 1, newValue) 对于第二种问题:1vm.items.splice(newLength) 还是由于JavaScript的限制，Vue不能检测对象属性的添加或删除，所以对于已经创建的实例，Vue不能动态添加根级别的响应式属性。比如:1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;); 如果你想要动态的添加属性到userProfile对象中:12345678910111213Vue.set(vm.userProfile, 'age', 27)// 或者别名方法:vm.$set(vm.userProfile, 'age', 27)// 如果你想要一次性添加多个属性，不可以像下面这样做Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;)// 应该这样vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) v-for with v-if 在vue的官方文档中强烈建议不要将v-if和v-for使用在同一个元素上，这样做的目的一般都只有两个: 过滤一个列表中的项目 为了避免渲染本应该被隐藏的列表 对于第一种目的，我们可以通过一个计算属性去达到这样的目的，或者也可以调用一个返回数组的方法。比如使用计算属性:1234567891011&lt;p v-for=\"user in users\" v-if=\"user.isActive\"&gt;&lt;/p&gt;&lt;!-- 你可以将users改成一个计算属性activeUsers --&gt;&lt;p v-for=\"user in activeUsers\"&gt;&lt;/p&gt;computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 第二种，我们可以将v-if移至v-for标签的上层。比如:12345678910111213141516&lt;ul&gt; &lt;li v-for=\"user in users\" v-if=\"shouldShowUsers\" :key=\"user.id\"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 相反我们应该这样写 --&gt;&lt;ul v-if=\"shouldShowUsers\"&gt; &lt;li v-for=\"user in users\" :key=\"user.id\"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 而且，当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以如果我们将其放在同一个元素上面，如果我们对数据进行了修改，那么在重渲染的时候又会去遍历整个数据列表。而我们如果选择使用一个计算属性，我们在渲染的时候只遍历活跃用户，渲染更高效，而且这样解藕渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。 组件的 v-for 在自定义组件里，你可以像任何普通元素一样用 v-for。并且在2.2.0+ 的版本里，当在组件中使用 v-for 时，key 是必须的。1&lt;my-component v-for=\"item in items\" :key=\"item.id\"&gt;&lt;/my-component&gt; 但是区别与一般的元素的是，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用props。这样做的官方解释是明确数据来源，达到组件复用的目的。二是为了防止组件与v-for过度紧密耦合。比如:123456&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; 除了key作为标识需要的属性之外，其它如item和index都是最后赋值到了props这个数组的中所定义的变量名称，然后这些变量名称将会使用在template定义的组件里。 小结 条件渲染和列表渲染有点类似于流程控制之类的东西，不过也只是简单的类比。条件和列表是一个很常用的功能，尤其是对于一些列表式的组件，但是还应该知道v-for和v-if配合使用的问题，从性能角度考虑，我们应尽量避免将v-for和v-if使用在同一个标签的上层。","categories":[{"name":"UI","slug":"UI","permalink":"http://swcheng.com/categories/UI/"},{"name":"VUE","slug":"UI/VUE","permalink":"http://swcheng.com/categories/UI/VUE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"Vue基础-数据绑定","slug":"Vue基础-数据绑定","date":"2019-04-20T12:47:00.000Z","updated":"2019-10-11T08:15:12.090Z","comments":true,"path":"2019/04/20/Vue基础-数据绑定/","link":"","permalink":"http://swcheng.com/2019/04/20/Vue基础-数据绑定/","excerpt":"在引入Vue需要的js文件之后，比如我们在js代码里创建下面这样一个Vue对象:","text":"在引入Vue需要的js文件之后，比如我们在js代码里创建下面这样一个Vue对象: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 声明一个组件Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;);var app = new Vue(&#123; el: '#app', data: &#123; message: \"Hello World!\", seen: true, dynamicId: \"iamid\", attributeName: \"href\", addre: \"http://www.baidu.com\", isDisable: true, vhtml: \"&lt;input&gt;\", firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' todos: [ &#123;text: \"Learn JavaScript\" &#125;, &#123;text: \"Learn Vue\" &#125;, &#123;text: \"Build something awesome\" &#125; ], groceryList: [ &#123; id: 0, text: 'Vegetables' &#125;, &#123; id: 1, text: 'Cheese' &#125;, &#123; id: 2, text: 'Whatever else humans are supposed to eat' &#125; ], // class和style属性的绑定 isActive: true, hasError: true, classObject: &#123; cla1: true, cla2: true &#125;, ind1: \"class1\", ind2: \"class2\", activeColor: \"red\", fontSize: 20, styleObject: &#123; color: 'pink', fontSize: '13px' &#125; &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;, computed: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;); 文本解析 可以使用Mustache标签去做原始的文本解析，这样的解析后的结果不会作为html代码输出:1&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;/span&gt; 结果显示:1&lt;span&gt;Message: Hello World!&lt;/span&gt; 如果不希望span里的内容随着message的属性变化而变化，可以使用一次赋值，下面的messgae的值不会改变:1&lt;span v-once&gt;Message: &#123;&#123; message &#125;&#125;&lt;/span&gt; Html解析1&lt;span v-html=\"vhtml\"&gt;&lt;/span&gt; 解析后的结果为:123&lt;span&gt; &lt;input&gt;&lt;/span&gt; 属性解析 使用v-bind指令:1 &lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; 解析结果:1 &lt;div id=\"iamid\"&gt;&lt;/div&gt; 动态绑定对应属性:1 &lt;a v-bind:[attributeName]=\"addre\"&gt; ... &lt;/a&gt; 该节点对应的vue对象的attributeName的值将作为将要设置的对应属性。如果是href记得要加http://前缀，不然会当做ftp。一个需要注意的地方是attributeName在有些浏览器会被全部被当做小写去解析，所以这个值我们尽量可能在vue对象中定义为小写。 当然也可以解析除了id之外的其它任何属性。注意以上无论是使用v-指令亦或者是Mustache标签，都可以使用js表达式去获得最终的值，但是仅仅可以使用一个js表达式去计算，而不可以写一堆js语句。 计算属性 计算属性是我们在vue对象中定义的需要通过一些js代码计算获得最终值的属性，这些属性的变化取决于它需要计算的属性的变化，这个对应的属性被称为响应式依赖。比如这里的message是需要被计算的对象，当message变化的时候reversedMessgae属性就会发生变化。123&lt;div id=\"example\"&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 如果你不想要当响应式依赖改变的时候才可以改变计算属性的值，你可能想要自己手动直接修改，那么可以为这个计算属性添加一个setter方法。(这里的cache意味着你访问这个computed的值的时候，仅当响应式依赖发生改变的时候才会重新执行getter函数，如果没有cache则会每次访问都重新调用getter方法。)下面的示例中，即使我们重写这个set方法，直接给fullName赋予的新值作为newValue出现在setter的第一个参数中，如果我们想要再次访问修改后的计算属性值，我们必须去修改它的响应式依赖，因为当再次访问计算属性就会调用get方法，所以只可以通过间接的修改响应式依赖的方式去达到修改计算属性的目的。123456789101112131415computed: &#123; fullName: &#123; cache: false, // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 侦听属性 侦听属性，就是我们需要进行监听其值的变化的属性，然后执行我们需要的操作。每当firstName或者lastName的值被修改的时候，对应的watch方法就会被调用。12345678watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125;&#125; 对于class属性以及style属性，如果去做一些字符串拼接和计算，则会特别繁琐，故而vue对这些属性的绑定做了一些特别的处理。 计算属性 vs 方法 在vue中，不只是计算属性是可以根据响应式依赖变化去重新计算求值的，我们可以通过定义一个方法返回这个计算值同样可以达到目的。但对于绝大多数情况，从直观的角度来看，使用计算属性是更好的满足这一类需求的方式，但方法的优点是可以传递参数，这样我们可以根据参数的不同编写更加通用的响应式返回值。所以从某种观点出发，方法是更为通用的”计算属性”。除此之外，方法并无cache，每次触发重新渲染的时候总会执行方法，对于一些非响应式的依赖值比如Date.now()，方法总会重新计算它们的值。这是二者的优缺点的比较。 class属性绑定 直接引用vue对象中定义的对象或者手动创建一个对象亦或者是一个属性，或者是使用一个包含对象以及属性的数组:12345678910&lt;!-- 直接在双引号中使用js表达式返回一个对象，如果在vue对象中，isAcitve是true则存在这个class否则就是没有 --&gt;&lt;span v-bind:class=\"&#123; active: isActive, 'text-danger': hasError&#125;\"&gt;&lt;/span&gt;&lt;!-- 直接引用一个对象 --&gt;&lt;span v-bind:class=\"classObject\"&gt;&lt;/span&gt;&lt;!-- 传递一个数组，这里是将数组里的属性的值作为标签的类的值 --&gt;&lt;span v-bind:class=\"[ind1, ind2]\"&gt;&lt;/span&gt;&lt;!-- 也可以将属性和对象共同使用 --&gt;&lt;span v-bind:class=\"[ind1, ind2, classObject]\"&gt;&lt;/span&gt;&lt;!-- 在数组中还可以使用三元表达式 --&gt;&lt;span v-bind:class=\"[isActive ? ind1: '', ind2]\"&gt;&lt;/span&gt; 解析结果:12345&lt;span class=\"active text-danger\"&gt;&lt;/span&gt;&lt;span class=\"cla1 cla2\"&gt;&lt;/span&gt;&lt;span class=\"class1 class2\"&gt;&lt;/span&gt;&lt;span class=\"class1 class2 cla1 cls2\"&gt;&lt;/span&gt;&lt;span class=\"class1 class2\"&gt;&lt;/span&gt; 对于自定义组件，如果在定义中就已经存在一些值，那么会在其后进行追加:12&lt;!-- 组件的定义必须放在最前面 --&gt;&lt;my-component v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/my-component&gt; 解析结果:1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; 可以与普通的class属性共存，也就是可以使用class与v-bind共同完成属性的设置:123 &lt;!-- 也可以与普通的class属性共存 --&gt;&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 解析结果:1&lt;div class=\"static active text-danger\"&gt;&lt;/div&gt; 绑定内联样式123456&lt;!-- 绑定内联样式，使用对象去绑定，不过定义在vue对象中更加合适 --&gt;&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;&lt;!-- 定义在对象中，当然也可以使用数组来引用多个对象 --&gt;&lt;div v-bind:style=\"styleObject\"&gt;123&lt;/div&gt; &lt;!-- 可以为一些属性添加多重值 --&gt;&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt;&lt;/div&gt; 解析结果:123&lt;div style=\"color: red; font-size: 20px;\"&gt;&lt;/div&gt;&lt;div style=\"color: pink; font-size: 13px;\"&gt;123&lt;/div&gt;&lt;div style=\"display: flex;\"&gt;&lt;/div&gt; 命令缩写1234567891011&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt; 注意 在编写这篇Vue笔记的时候，会出现Mustache标签与Nunjucks语法冲突的问题，解决方案可以查看 这里。","categories":[{"name":"UI","slug":"UI","permalink":"http://swcheng.com/categories/UI/"},{"name":"VUE","slug":"UI/VUE","permalink":"http://swcheng.com/categories/UI/VUE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"找工作的一些感受","slug":"找工作的一些感受","date":"2019-04-19T12:09:00.000Z","updated":"2019-05-19T09:42:05.866Z","comments":true,"path":"2019/04/19/找工作的一些感受/","link":"","permalink":"http://swcheng.com/2019/04/19/找工作的一些感受/","excerpt":"因为去年的辞职，而且是在没有找到下一份工作的情况的裸辞，所以今年开学之后做的第一件事情重写简历，然后投简历寻找下一份工作。但是让我没想到的是自己寻找工作的过程会这样的不顺利，也在这个过程中体会到了找工作的不易，以及自身力量的渺小。","text":"因为去年的辞职，而且是在没有找到下一份工作的情况的裸辞，所以今年开学之后做的第一件事情重写简历，然后投简历寻找下一份工作。但是让我没想到的是自己寻找工作的过程会这样的不顺利，也在这个过程中体会到了找工作的不易，以及自身力量的渺小。 前后先是接到一些来自hr的电话，因为自己投递了不同城市的职位，所以接到了不同城市的电话，有来自北京的，也有来自上海的，但大多还是来自上海的电话。问的问题基本上是这么几个，你几月份毕业，四六级过了吗，专业成绩排名，有拿过什么奖吗，为什么从前一个公司离职，一周能来实习几天，什么时候可以过来实习，期望薪资是多少……还有hr问我你认为自己适合搞技术么。 刚开始找工作自己还算是比较自信，自以为凭借自己现在掌握的知识水平，如果有公司愿意去培养一个新人，应该是可以能够获得一份自己想到去做的职位，所以自己刚开始在简历上写的是大数据开发岗位而不是自己之前实习做过的Web开发。但是自己所有的职位也都会去投递，包括大数据、Web、以及爬虫，因为想着即使人家不要我也可以混个面试经验，看看他们都问些什么。刚开始是十分想去做自己想去做的东西，所以当接到hr的电话的时候，我会问对方有没有大数据的业务，以及是否可以在完成本职工作的情况下去任职不同形式的工作，还会和对方聊由于自己毕设的原因所以可能不会去实习，即使去实习也是快要到毕业的时候，因为自己想要花更多时间在自己的毕业设计上面，以及在被问到薪资的时候毫不犹豫的说12-15k。 所以在之前以前面的方式和hr聊过之后，基本没有hr会再去联系我。开始自己没有明白原因，直到后来在拉勾上也不知道投过多少份简历和在BOSS上投过不知道多少份简历之后，以及面试过几家公司之后，才弄懂之前的原因。我觉得原因有一下几个，第一因为招聘的是应届生，所以其实对经验的要求并没有那么高，地位属于最低的那一群，人家觉得差不多能用就可以，拿过来实习一段时间就可以去干活，即使你可能比别人要强一点，但是人家根本不很care你如何，唯一的区别可能就是hr筛选简历的一个优势而已。第二是自己报的工资要求高了一些，除了像BAT或者其他大一点的公司可以对应届生开出11k以上的薪资，对于一些小一点的公司，基本不太能对一个应届生开出那么高的人力成本。第三我不接受马上去实习，前面也提到了，公司其实是希望你能够马上去为它们干活快速熟悉业务，因为这样你在和他们签订合同之前就可以尽快产生效益。第四，互联网寒冬，很多公司招聘的岗位都在缩减，甚至有些都在春季停止了招聘，所以就业的机会也变少了许多。 在经历了前面的经历之后，基本没有得到回复。在得到不友好的回馈之后，也明白了不是你想去干什么就可以的，招聘永远是看你是否存在它们需要的经验，能否为它们产生它们需要的利益，事实就是这样。而且大公司的招聘流程都很长，久到让你等到绝望，如果想要进入大公司应该提前很久去做准备，小一点的公司的话招聘流程不会那么久，如果你想换一个大一点的公司进去取取经，那么就应该在离职前很久就做准备，不然你就会感受到裸辞之后一个较长的失业期。其实裸辞是一个不理智的行为，因为找工作的话很多公司是看你是不是完全适合它们公司的业务，因为即使他们缺人，业务也可以照常走，也不会那么着急的去招你进去，他们完全不着急，因为招聘对于他们来说只是工作的一小部分，但是对于一个失业的求职者来说就恰恰相反了。 记得第一次面试是去一家叫什么图丽信息的公司，那天我跟在hr后面进门的时候看到手机有信息，就打开手机看看是什么内容。后来居然被那个技术总监认为自己进门在玩手机这么不认真，我实在对那个技术总监牛批的态度搞得有些不爽，一幅上位者的嘴脸。我就故意说为什么不可以看消息，万一有什么重要的消息怎么办。接下来就是他看到我在前面填的一个表很多没填的地方，我就说不想填，因为很多内容你们有我的简历，属于重复内容，不需要填，面试官看我态度这么硬，还问自己家里条件是不是很好，还有自己是不是对他们公司根本看不上。本来没有什么，就是很讨厌他那种作为技术总监一上来就给自己一种不尊重的自以为是的感觉，我宁愿不要这份工作也不愿去理会这种人。因为即使去了以后也只会更难受。 总之那天就是自己今年面试的第一个公司，也是自己和他们的技术总监互相看不上暗中互怼的一次面试。因为那个公司位置比较偏僻，所以自己从他们公司出来，转乘公交之后突然迷了路，也不想直接回学校。下了车自己就走在一条空荡的小街，冷风肆意吹在自己的身体上，身体忍不住颤抖，肚子很饿，但又没碰到一家餐馆，只能挨着饿空着肚子继续往前走，想着自己处于失业状态，如果没工作就连买饭的钱都没有，但作为生存最低的要求是可以有钱能够买口饭吃。这让我想起乔布斯在辍学之后，睡在同学宿舍的地板，回收可乐瓶维持买口饭吃，并为了吃饭走上七英里的路程，穿过波特兰市区去到一个被叫做Hare Krishna的神庙，仅仅是因为这家寺庙每周日有灵修活动和免费聚餐。还有周星驰在电影新喜剧之王里描述那种为了演戏不要钱只是为了吃口饭的场景。以前这种只是在书里和电影里看到却无法感同身受，那一刻自己是有真的体会到那种为了生存无奈的感觉，也感受到生活好像不过就是这样，忙忙碌碌只是为了吃口饭，有个地方可以落脚，真是空洞又现实。 也就是在那段时间，自己开始思考自己的职业道路，想要试着去跟随自己内心的想法，仅凭着感觉去做其它的职业而不问结果，想着混差点又怎样呢。所以之后自己在三月二十号去面试了宇视科技的销售岗位，它们在我们学校进行面试，可以说挺会替学生考虑，避免了我们学校一群人往他们公司奔波而最终没有面试通过的失落感。因为自己没打印成绩单的原因，所以提早去教务处打印成绩单，然后直接去到面试的地点。因为我提前十多分钟到了，而这时他们的面试人员以及都到了，我就直接和他们的销售面试官开始了面试。 其实对于这种正在开拓市场的公司，销售在这种公司的地位是很高的。这也是自己后来才开始明白的，也正是这帮销售，才是公司真正的收入的起点。但是要想把销售干好，没有很深的积累和很好的口才是不太可能的一件事情。 之后面试官就拿着他们手上我的简历开始对我的询问，与一般的技术面试的开场就不同，首先对我说你是南昌人?我想了想，还是回答了我是湖南永州人，可能之前在你们的资料上没有认真填写信息所以你手上看到的我是南昌人。面试官又说，那你是湖南人，你们那里是有很多土匪呀。我只能笑着说刚改革开放那段时间是这样的，尤其是在湘西那一块儿。之后就是我和面试官之间长达四十分钟的聊天,不过真的很轻松愉快，一次很难忘的经历。-.- 面试官看上去的年龄大概有四十多接近五十的样子，开始和面试官聊了我之前的一些在学校的实践经历以及自己在认识到一些事情的本质之后的失望与不屑，以及在自己长时间的努力之后但结果却差强人意的失落感，以及那之后很长时间都没能走出那段低落的状态，还有简单的谈了谈自己对为什么想要做销售的原因和理解等等。面试官是一个很不错的人，因为让我觉得他是在用真心和我交谈，我也能感受到他是一个十分负责人的人，也针对自己的一些经历和想法给自己提出建议，是一个很成熟温和的北方男人。我很感谢也很开心能够和他这样一位对问题了解深刻的人去聊天探讨，毕竟这样的对话还是很少很难得的。 具体细节就不在博客中记录了，因为很多都是使用事实和比喻进行讨论与论证，但最后我确实是被他说服了。他最后给我的建议是，不能够在自己对一件事情没有多一些准备和了解的情况下去做决定，而且应该选择一条路去不断往下深入，由于社会的现实与残酷，更加应该选择自己当前最擅长的东西去做，如果对一个东西有足够的兴趣，可以不妨在养活自己的前提下去实践。 这种方式我在认真思考之后，觉得是较为理性的方式。按照自己的性格来的话可能会说追求自己想要的东西就会不遗余力，喜欢把自己逼到绝境爆发出来的那种力量，但是许多事情更加需要理性去处理，要弄明白自己的真正的内心的感受的时候才去做决定比较合适，即使是需要把自己逼到绝境，也是需要自身有一些积累才行，这种积累更是一种成熟，在行动之前多了一份对自身与他人的理解，对社会现实的认识。 所以以后自己无论想去做尝试的时候，不妨可以自行去往深入探索，而不能仅停留在感觉上的认识，对自己多一些沉淀，在真正对其有一些理解的时候，再去做选择或许更为合适。 另外一个面试官教我的理论让我印象特别深，他对我说，你是不是想要证明自己。我仔细想了想，虽然不是喜欢张扬的人，但确实是想要证明自己，所以我果断的说对的。然后他对我说，你知道为什么很多热点就突然消失了吗？我仔细想了一会儿，就回答说因为他们根本不关心。面试官后来阐述说的其实和我的回答差不多，其实每个人都对与自己无关的事情不会投入很多关注，无论这个人有过多高的成就，虽然他说的很冷漠，但是却直戳事实。 记得看过一篇文章，写的是作者在一个餐厅靠窗的位置吃饭，突然就一个东西从楼上掉下来，把餐厅的玻璃都砸碎了，差点砸到他，可想而知如果砸到他那么肯定是性命不保。当时那个东西掉下来的瞬间把整个餐厅的人都吓到了，也对作者的安全感到唏嘘，但很快他们就开始自己吃自己的饭，一切好像从未发生过一样。作者感慨他在生命受到威胁的时候，周围人的表现，让他真正认识理解到人们的冷漠。当然这不是针对人性善恶的讨论，只是一种对意识形态的观点。 其实表述这么多，只是想简单的说明一个道理，人真正的幸福不可能来自于他人，去做真的可以令你感到轻松愉快的事情，只有你自己真正开心快乐才是真正获得了幸福，而且这只能是来自于自己的内心。如果你期望幸福来自于在他人心中的形象，那么让你失望的几率比较高。最近在读叔本华的人生的智慧，他在书中也恰好提到了同样的观点，我看到这部分的时候也感到十分认同。当然我不是对他在书中写的全部观点都表示赞同，从他的文字可以感受到这是一个有些孤傲高冷的人，但我认为这是他性格上的缺陷，也导致了他的有些文字有些偏颇而不够完美。虽然在我心中不够完美，自己还是很喜欢这个哲学家，因为他在这本书中写的很多事情都是具备着深刻的思考。 记得叔本华阐述了一个十分有趣的观点，他认为你观察自己周围的这些人，如果你想要了解这个人，你只要知道让他们感到开心的是什么事情就可以知道他是一个什么样的人。看到他写的这个内容我不禁会心一笑，难怪他会说你要是想和从聊天中获取到快乐你必然是失望的，因为一百个人很难有一个不是傻子，还有女人都是浅薄无趣的这样的话。虽然这样的话可能会让很多人站起来反驳，说这人绝对是个傻逼，你算什么东西也敢批判女性。但我认为，如果没有任何独立思考的意识，那么其言论看来也是可笑的。 想清楚这些事情之后，开始修改简历，重新开始找工作。之后陆续去面试了不同规模的公司，最后也得到了offer。每次我去面试的时候，我都会把自己填的表格写的题目的那一瞬间拍照记录下来，因为我想提醒自己记住这个场景。这一刻的无奈，这一刻的沮丧，这一刻的难受，这一刻的渺小，并提醒自己说自己真的很tm讨厌填表，也决不能有下次再有填表的可能。 这一次的经历也是在教会自己，对任何事情或的人的期望都应该在自己心里减少，因为只有自己才可以让自己散发出光芒，所有的愤怒、失落其实都应该去归根于自身的无知和意志的薄弱。可以输，但不能怂。 Last but not least,you can only enjoy yourself,not anyone else.And just share with people having the same hobby.","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"EXPERIENCE","slug":"EXPERIENCE","permalink":"http://swcheng.com/tags/EXPERIENCE/"}]},{"title":"早上五点的清晨","slug":"早上五点的清晨","date":"2019-03-18T11:17:00.000Z","updated":"2019-05-19T09:42:05.867Z","comments":true,"path":"2019/03/18/早上五点的清晨/","link":"","permalink":"http://swcheng.com/2019/03/18/早上五点的清晨/","excerpt":"不知什么原因，昨天十点半上床睡觉的自己，今天凌晨三点十多分我就醒了，看了下手机闪烁的绿灯，是有没有查看的通知。打开手机一看，原来是我妈发过来的三条信息，发送时间显示是凌晨1:19分，查看了聊天信息后，原来是我昨天和我妈聊天聊到自己关于自己职业的一些思考，觉得做技术好像对于自己来说没有觉得特别开心，感觉一直是在进行一段孤独的旅程，并感慨根据自己对于自己的了解来说，想要在技术上有所成就，做出一些能够真正了不起的事情，还是得进入一个非常好的团队才行，但这种事情是可遇而不可求的，我觉得自己似乎不会那么幸运。而且长时间坐在计算机前面写代码确实是一件非常伤身体的事情，因为去年的时候我去医院检查眼睛就发现自己因为经常熬夜磕代码导致晶状体轻度浑浊，眼睛前面有时候会感觉到一些黑色的漂浮物在游荡，除此之外还有许多我没有和我妈说过的事情，只不过自己都选择隐瞒在心里。","text":"不知什么原因，昨天十点半上床睡觉的自己，今天凌晨三点十多分我就醒了，看了下手机闪烁的绿灯，是有没有查看的通知。打开手机一看，原来是我妈发过来的三条信息，发送时间显示是凌晨1:19分，查看了聊天信息后，原来是我昨天和我妈聊天聊到自己关于自己职业的一些思考，觉得做技术好像对于自己来说没有觉得特别开心，感觉一直是在进行一段孤独的旅程，并感慨根据自己对于自己的了解来说，想要在技术上有所成就，做出一些能够真正了不起的事情，还是得进入一个非常好的团队才行，但这种事情是可遇而不可求的，我觉得自己似乎不会那么幸运。而且长时间坐在计算机前面写代码确实是一件非常伤身体的事情，因为去年的时候我去医院检查眼睛就发现自己因为经常熬夜磕代码导致晶状体轻度浑浊，眼睛前面有时候会感觉到一些黑色的漂浮物在游荡，除此之外还有许多我没有和我妈说过的事情，只不过自己都选择隐瞒在心里。 我觉得能够真正做出影响某个行业的事情或者改变人们生活的事情的人只有两种，要么是对于某个事情有着真正发自内心的热爱，要么是拥有惊人的自制力。从大学开始正式接触计算机，(之前只能算作会用电脑打游戏)因为到了大学自己才真正拥有自己的电脑，当初想要学习计算机主要有两个原因，一是自己确实比较喜欢玩游戏，所以也比较喜欢玩电脑；二是和朋友一致认为计算机是一个将来可以搞出一个名堂的行业，所以决定投入到其中去。到了大学开始学习编程语言之类的课程，其实刚开始学编程也没有什么特别的技巧，就是硬磕，程序运行不起来直到调试到运行起来为止，之后就是渐渐养成一些对程序的认识的意识，就代码看的多了，记的东西多了，也渐渐能够对一些简单的逻辑代码做到顺其自然。 我自认为在学习代码的过程中有很多探索的乐趣，因为自己是在自己的好奇心的驱使下去解决一个又一个的问题，但是逐渐发现自己陷入了一个瓶颈，对于很多东西似乎只懂得如何去使用，却不明白它其中的原理。这时候才认识到之前阿里老程序员的建议，不过真的要做到对原理的探索确实是一件非常困难的事情，自己确实还离那个水平差距很远，但不知道为什么，自己却很难再去向这一步迈出探索的步伐，好像就像梵高的那句话说的一样，每个人的心里都有一团火，却从不曾拿出来暖和自己，而自己心里的那团火好像已经快要熄灭，无论怎样想要将其拿出来暖和自己都做不到。 我发现自己也特别喜欢与不同的人聊天，去了解一个人思想，一个人的经历，发现每个人的不同，思考一个人的生活轨迹，以及为什么会这样进行下去的原因。每一次与人的交流都让自己觉得特别开心，因为自己的思维触碰到了一些新的东西，当然也会有不开心的时候，不过这是因为对方的思考问题的态度让要么我觉得与自己对人生的态度相悖，要么就是太简单的无所谓让我感受不到生活的乐趣。每次思维的碰触都让我觉得比较兴奋，而此刻我也觉得这是自己可以真正感到快乐轻松的事情，对比与代码的感觉，所以我昨晚和我妈聊天的时候才会想要去说自己要不改行去做一些其它的事情之类的话。 我妈发的信息的内容的大概意思是想要表达的是钱很难赚，世界上没有两全其美的事情，其实当时我的心情是有点生气，有点觉得我妈不够能理解自己，也觉得自己好像每次做一次决定都会遭到家里人的阻挠而不是得到鼓励。其实我真的有认真思考过每次决定，而不是随意去做一个决定，只是总是没有得到理解和支持。甚至当时自己对家人还感到一些失望。但是现在我再去看同样的消息内容，我再去看同样的话语的时候，理解到感受到的是我妈焦急的心情，也觉得自己其实有很多话没有能够对她说的足够清楚所以才导致我妈不够能理解自己。但是自己就是一个不太爱什么话都说的人，希望自己以后可以做到多去大胆随意的表达自己的一些想法。 今天是因为老友要来上海参加复试，为了去火车站接他自己五点多就起床，洗漱之后就匆匆往上海南出发。凌晨五点的校园除了鸟叫，路边还没熄灭的灯光，以及在宿舍门口没带卡等待着开门的一个彪形大汉，(吓我一跳..=.-)，就是夜色笼罩着整个校园，走在空旷的580大路上，感觉特别开心，无所顾忌的在校园里唱着女神的第一首专辑的第一首歌超快感，心里默念”很孤独，却很爽”。 那一刻自己真的是觉得，自己被太多的思虑拖得失去了自己本来的色彩，为何不踏着轻松愉快的节奏，去简单的做任何事情，just do it.这不是自己17年一直让自己坚持下去的信条嘛，所以与其再去陷入不开心的思考，不如把握好当前的每一秒钟，别让其在无意义的思考中流逝，所以，当自己下次再对生活感到心灰意冷的时候，不妨再去体会一下早上五点的清晨。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"花卉市场&龙华古寺之旅","slug":"花卉市场&龙华古寺之旅","date":"2019-03-10T13:43:00.000Z","updated":"2019-05-19T09:42:05.869Z","comments":true,"path":"2019/03/10/花卉市场&龙华古寺之旅/","link":"","permalink":"http://swcheng.com/2019/03/10/花卉市场&龙华古寺之旅/","excerpt":"这周为了完成将腾讯新闻爬取到数据库的任务，搞得自己有点精疲力尽，眼睛也有些受不了长时间的工作，意识又陷入被程序捕获的状态，所以我在写完这个代码之后，当即决定去操场跑步先放松一下自己的身体。再想着周六日去哪儿逛逛放松一下自己的精神。","text":"这周为了完成将腾讯新闻爬取到数据库的任务，搞得自己有点精疲力尽，眼睛也有些受不了长时间的工作，意识又陷入被程序捕获的状态，所以我在写完这个代码之后，当即决定去操场跑步先放松一下自己的身体。再想着周六日去哪儿逛逛放松一下自己的精神。 为了编写这个程序，在经历了使用Scrapy+Splash的失望的情绪之后，决定愤然不使用框架，自己使用Python Http请求库requests编写程序根据程序请求的api实现自动化抓取新闻数据并最终写入数据库。虽然最后也完成了这个任务，但是还是觉得这之间有太多的小细节搞得我痛苦不已，经常会被腾讯新闻参差不齐的json数据返回结果解析搞得头疼不已，加上它本身的url格式不同且请求数据方式不同，所以我不得不将程序的逻辑复杂化。 em…所以在写完这个程序之后，自己在感慨框架确实是一个好东西，至少每个站点的数据请求方式以及模式都不相同，如果每次我们想要爬取一个站点的数据都去编写一个这样的逻辑，实在是一个费劲的工作，而框架就为我们解决这类问题提供了一个通用的方法，不得不为前辈们的智慧心血感到佩服。工作归工作，生活还是蛮重要的，还是回到文章的正题，花卉市场以及龙华古寺之旅 u_u 上海有很多花卉市场，但是经过考虑之后，我选择了钦青花卉市场，因为看评论以及评分好像都还不错，距离也还行，就决定去了。 一路奔波，终于到达了目的地，从外面来看好像还不错 (✪ω✪) 然后就是到里面到处逛，发现了很多好看的植物…我看着这些植物…有一瞬间感觉自己也只是一个会移动的生命而已，除此之外和它们一样只是在简单的存在着的生命体而已，没有什么特别之处。其它的好像也没什么值得说的，不如贴一些图片吧 ヾ(ｏ･ω･)ﾉ 逛了前面的花卉市场，这后面紧接着还有一个市场，像是以前传统一点的老花卉市场，虽然装修上不如前面的花卉市场，不过也很有意思。里面除了有一些花卉之外，还有一些动物，比如鱼、鸟、兔子、乌龟等之类的。本来自己是有买几条鱼回去养的念头的，但是后来想想还是算了，毕竟一个小鱼缸里放几条鱼感觉也怪没意思的，一点都不具备观赏性，也不热闹，甚至还会感到有些冷清。而且宿舍也不具备那个条件，不如等以后又条件了自己再弄一个大鱼缸，再搞个氧气泵，这样就可以开心的养各种各样的鱼了。看着这些鱼类，不禁让自己回忆起曾经在北京去过的一个水族馆，当时第一次看到那么多种类的海底动物，感觉很震撼，第一次觉得水底世界特别的美，下次一定还要去一次水族馆…就是门票费感觉不太便宜 T_T 不多说了，赶紧贴一些图片吧。(感觉蓝色的鹦鹉贼好看 (๑╹◡╹)ﾉ”””) 花鸟市场逛完之后，本来看时间还早，打算去下一个花鸟市场看看有什么不一样没有，但是还是机缘巧合的在路中发现了龙华寺，早就听说过这个寺庙了。因为易中天每年春节都要来上海龙华古寺参禅斗诗，所以当自己路过龙华寺的时候，多半是掺杂的是对易大师的敬仰，就兴冲冲的往龙华寺奔去了。仔细回想为什么自己会如此喜欢易中天，还是结缘于他的品三国系列，除了他的品三国之外，我也听了很多关于他在其它方面的言论，以及读过他的读城记，也去了解过他的一些经历，可以说是自己非常喜欢的一位大师了，至今在自己的宿舍还摆着他的书，虽然这些书自己现在还并没有怎么看.. (´･ᴗ･`) 突然有点怀念超喜欢易中天还处于高中时候，也超喜欢我高中的物理老师易大师，我觉得他们都是真正属于自由率性的人，好像前几天自己还做梦梦到自己又碰到自己的高中物理老师，自己很高兴但对方好像不怎么爱理我…(﹂_﹂)。其实有想要回家的时候把易大师约出来吃个饭的，但是手机号码在自己之前的手机里被自己搞丢了。并且又想到自己还经历比较浅，也没搞出什么名堂，不如再过几年等自己再成长一段时间再去找他唠嗑聊天，或许那时候会聊得比较好吧。 em…还是将目光切换到龙华古寺…既然来了，不如入乡随俗，那当然少不了拜佛祖、拜菩萨，许下了自己的小心愿。嗯…肯定许的不是下面这个愿望。 12345678910111213141516171819202122/* _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / /======`-.____`-.___\\_____/___.-`____.-'====== `=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG*/ 附上一些龙华寺的照片。 又去逛了旁边的龙华烈士陵园。 最后叶挺将军的诗句让我觉得特别震撼，记得这是小学语文课本上的文章，当时不知道什么叫狗洞，还以为是在一个监狱里特地为囚犯打了一个狗洞可以钻出去。-.-。尤其是最后一句”我应该在烈火与热血中得到永生”，我体会到了话语中为了心中的理想不顾一切的热血与疯狂，他们注定是时代的缔造者。北伐期间的叶挺独立团，即使距离现在这么多年，也依旧不能不对这支铁血之师报以敬畏之心。 All dream never die.","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"STROLL","slug":"STROLL","permalink":"http://swcheng.com/tags/STROLL/"}]},{"title":"上海仙人掌养殖基地之旅","slug":"上海仙人掌养殖基地之旅","date":"2019-03-03T07:17:00.000Z","updated":"2019-05-19T09:42:05.864Z","comments":true,"path":"2019/03/03/上海仙人掌养殖基地之旅/","link":"","permalink":"http://swcheng.com/2019/03/03/上海仙人掌养殖基地之旅/","excerpt":"计划这周六去上海仙人掌养殖基地看看，上网搜索了一下，然后一个叫做上海金欣仙人掌种植专业合作社的名字出现在我的视野里。在高德地图上搜索位置，发现在金山区，已经基本属于上海最南部分靠海的区域，从学校出发到那里，差不多是横跨了整个上海市，｢(ﾟﾍﾟ)。我们可以从地图上看出来到底这两个地方距离到底有多远…","text":"计划这周六去上海仙人掌养殖基地看看，上网搜索了一下，然后一个叫做上海金欣仙人掌种植专业合作社的名字出现在我的视野里。在高德地图上搜索位置，发现在金山区，已经基本属于上海最南部分靠海的区域，从学校出发到那里，差不多是横跨了整个上海市，｢(ﾟﾍﾟ)。我们可以从地图上看出来到底这两个地方距离到底有多远… 然后昨天也正好下雨，约好朋友九点一起去的，但早上九点给人家发消息打电话都没有回应…估计是把这事儿忘了昨天玩的太晚然后还没起床，我就等了半个小时，打了三个电话，都没人接。看着外面下着下雨，约好的朋友又没来，看着室友都还在睡觉，心里有点想放弃，觉得要不今天当个咸鱼宅在宿舍得了，但是这个念头马上被自己否决了，想起自己给自己定的目标周六日一定不学习，并且按照自己的性格，这么快放弃自己都要鄙视自己。于是哼着”环游世界，不在乎明天天气”开心的出发了啦啦啦 o(＊＾▽＾＊)o♪ 但自己没有听从高德地图的指示，内心觉得高德地图上指示的纯公交线路肯定慢的一批。所以我按照目的地的位置，又参照了地铁线路图，我决先乘8号线-1号线-5号线，到上海最南的一个地铁站奉贤新城，然后到了奉贤新城再乘公交去目的地。但是我打到奉贤新城的时候，已经是十二点了，于是决定先吃个饭再出发…本来以为奉贤新城肯定能找到吃饭的地方，但是让我感到意外的是这里虽然是周六，但没几个人出现在应该是最繁华的地方，看了看地铁站旁边的商业广场，居然都没有开业…我心想这是什么鬼…于是自己只好导航到附近的永和大王，但按照地图导航也走了1km才打目的地，看着空旷的地方，街道上都没几个人，旁边的房子倒是建的挺不错的。吃完饭看看时间已经是一点了，于是又按照地图上的导航，两次换乘公交，在公交车上睡了一觉，然后醒了发现时间已经到了差不多两点多，这会儿终于快到目的车站了。 下了车，再按照地图上的指示，左转右转终于到了目的地，看着眼前本应该是一片仙人掌种植基地的地址但却是一片荒地在我眼前…那种被高德地图欺骗的感觉涌上心头…心中默念”去TM的篮球梦”。没法只好一路问这个村的村民以及在最后问了一个保安大哥之后终于找到了我想到的地方，当自己看到标牌以及前面的种植大棚的时候抑郁不住激动心中的心情赶紧拍个照。 刚进去被门口叫的很凶的狗吓得够呛，但那狗很奇怪，叫的很凶但却一点都没有要咬人的意思，于是胆战心惊的走过狗之后继续往里走，结果又是一群狗，这回是没栓链子的一群狗，我不敢往前走了，就大喊向前大喊”有人吗”。看见一个人从里面出来我顿时松了一口气，心想总算是找到组织了。 朱大哥一个人守在种植基地，人很好也很热情，刚进去就给我倒了杯仙人掌泡的水，然后就开始聊天。开始和我讲仙人掌是如何治好他的病的，当上海的四个专家都说他是没法恢复到之前的状态的时候，并且花了四五十w都没法治好的病，但是就是因为仙人掌，他的病神奇的得以完全康复，而且现在看不出与普通人有任何不同。同时也是因为这个原因，大哥毫不怀疑的决定自己种植仙人掌，这一种就是十七八年。 我没坐下多久，随后又有两个人来到了这里，和我来玩的目的不同，他们是来这里了解仙人掌的种植以及这里的发展情况的。那天聊了很长时间，大概内容是朱大哥与仙人掌结缘到自己建立仙人掌养殖基地的一些事情，听闻了朱大哥从决定种植仙人掌创业过程遇到的种种经历之后，心中对于他只有敬佩能够形容，我觉得他用自己的行动完美诠释了仙人掌的花语，坚强而坚定。我在想有几个人可以做到将房子和车卖掉去种仙人掌，体会那种没钱所有人都不愿意借钱给而当你有钱的时候大家都争着借钱给你的落差感，在付出了400-500w的投入之后没有看到收获，甚至就连合作的两个伙伴都选择离去，但他依然选择继续走下去的那份坚定与决绝，我觉得可以毫不夸张的说他将自己的生命与仙人掌绑定在了一起。抛开这些经历不说，还让我感到佩服的是朱大哥对于品格的那种坚守，即便选择没钱也绝不做违反自己原则违背良心的事情，我觉得在我们这个时代这种品格真的已经不多了。 其实我不想去抨击这个世界说人们有多虚伪虚伪，为了利益可以多么没有底线，但不想也不得不去承认，这确实是一个事实。但我个人觉得无论世界怎样好或者怎样坏，一定要恪守自己的原则，即使恪守原则是要付出代价，但我宁愿想真实一些也不愿用虚伪换回所谓的尊严。其实很多事大家都是心知肚明，只是没有人有勇气去做那个打破规则的人，也害怕那个代价自己难以承受，每个人都会做出自己的选择，但是我觉得为了自己的利益而不考虑他人情况的事情自己真的做不出。 有时候我有点感叹的想，好像我们面前的一些公众人物如刘强东、马云、王健林等的言论被人拿过来炒来炒去，媒体总是会对这些人投入了过多而从不愿对那些真正选择坚守品格但却经济拮据的人投以目光。我有时候在想这个时代衡量一个人是否被人尊敬的标准似乎成为了财富的多少，我承认这些人能够成功确实不乏有他们的个人魅力，不然也没法成为现在的巨头而不是其它人，而且这些能够如此成功的人我认为都是有着时势造英雄的因素，因为有很多人比他们还要努力，比他们还要值得尊敬，所以对于他们仍需要以客观的态度来看。我甚至觉得他们在公众面前说的很多话，自己本身都做不到，有时候可能是说的太多，反而失去了质实的那颗心。 这个世界虽然算不上特别好，但也算不上特别坏，不要去抱怨不公，只要肯坚持努力，机会总是在不远处等待着你。我只希望自己在每次做出选择的时候，能够做到问心无愧，有时候太在意别人的言论只会让自己更难受，自己在心里给自己一个答案就行了，剩下的就交给时间吧。 PS:最后附上我和朱大哥的合影hhh。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"STROLL","slug":"STROLL","permalink":"http://swcheng.com/tags/STROLL/"}]},{"title":"确认过眼神，你是我的仙人掌","slug":"确认过眼神，你是我的仙人掌","date":"2019-02-26T13:44:00.000Z","updated":"2019-05-19T09:42:05.868Z","comments":true,"path":"2019/02/26/确认过眼神，你是我的仙人掌/","link":"","permalink":"http://swcheng.com/2019/02/26/确认过眼神，你是我的仙人掌/","excerpt":"出于对仙人掌的喜爱一直想画一幅仙人掌的图画…然后发现了一张十分好看的仙人掌图画，就想着自己模仿一下。确认过眼神，于是一个晚上的时间都投入在它身上了。(^_−)☆","text":"出于对仙人掌的喜爱一直想画一幅仙人掌的图画…然后发现了一张十分好看的仙人掌图画，就想着自己模仿一下。确认过眼神，于是一个晚上的时间都投入在它身上了。(^_−)☆ 我觉得很大的缺点是整幅画颜色太淡了，感觉自己买的画笔无论我怎么用力去填涂都还是这么淡的颜色。还有感觉那个盆被我描绘的有些宽，应该再窄一些。还有就是由于颜色太淡，填涂的饱和与淡的层次感完全显示不出来，存在很多缺点，希望下次能画的好一点。=-=","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"DRAWING","slug":"DRAWING","permalink":"http://swcheng.com/tags/DRAWING/"}]},{"title":"开启新的运动,Yeah!","slug":"开启新的运动,Yeah!","date":"2019-02-23T11:05:00.000Z","updated":"2019-05-19T09:42:05.865Z","comments":true,"path":"2019/02/23/开启新的运动,Yeah!/","link":"","permalink":"http://swcheng.com/2019/02/23/开启新的运动,Yeah!/","excerpt":"不知道从什么时候起，觉得篮球好像很难点燃自己的热情了，也许是经常自己一个人和不同的路人打球，每个路人对待打球的态度不同，有的打球认真，有的打球随意，很难找到那种归属感。刚开始还好，但这样打的时间一长，就会经常打球感到无所谓的感觉，完全失去了当时打球的竞技的感觉。也就渐渐失去了对篮球的认真，变成了所谓的养生篮球，讲的直白点就是变成了篮球场上失去梦想的咸鱼。","text":"不知道从什么时候起，觉得篮球好像很难点燃自己的热情了，也许是经常自己一个人和不同的路人打球，每个路人对待打球的态度不同，有的打球认真，有的打球随意，很难找到那种归属感。刚开始还好，但这样打的时间一长，就会经常打球感到无所谓的感觉，完全失去了当时打球的竞技的感觉。也就渐渐失去了对篮球的认真，变成了所谓的养生篮球，讲的直白点就是变成了篮球场上失去梦想的咸鱼。 在今年2月13号的一天，那天下着雨，按照常理来说，又没有室内场地，是不可能去打球的，但我表弟明天就要从我家回去了，如果这次不和他打球就今年就没有机会一起和他打球了，所以我们决定即使下雨也还是要去打球。 我对篮球开始感兴趣的时候是在高一的时候，那时候和家里因为学习上的原因经常发生矛盾和争吵，不喜欢回家，和一个家在外县的同学也是刚好一起在宿舍，他提议我们去打球，我觉得打球是个新鲜事情对于我来说，就很高兴的答应了。自从那次打球以后，自己就不自觉的爱上了那种球入框的感觉，开始逐渐走上打球的不归路。这一打就是一个整个高中和大学，但是我打球打的晚，不像他们初中或小学就开始了打球这样，所以自己属于最菜的那种，也就是所谓的黑铁选手，(✪ω✪)。 所以作为黑铁和一群白银黄金选手进行游戏是经常遭受冷落的，这体现在不仅是在球场上很少拿到球，甚至有时候是遭到一些比较激进的人的言语攻击，那时候别提心里有多难受了。所以自己没事儿就去球场练球，想要提高一下自己的篮球基本功，但都是自己一个人没头脑的练习，其实从现在看来，练习篮球最后还是系统的有方法的练习，这样才能达到比较好的训练效果。但自己也没想那么多，就凭着热爱去不断练习感觉呗，一个人也能玩的特别高兴，记得是在高二的那年暑假，自己没事儿就去学校篮球场打球，即使下雨，也是高高兴兴的要去打球。印象比较深的是那个暑假自己在雨中打球第二天那个篮球就起了个包，之后那个包越来越大，很快那个球就根本没法打了，那也是自己寿命最短的一个球。 在13号那天自己在下了雨的场地打球，回忆起之前同样在雨中打球的感觉，好像篮球带给自己的快乐越来越少，已经完全体会不到这个运动的乐趣了。身体冷心也冷，在一番思想斗争之后我决定放弃篮球，寻找新的运动，开启一个新的学习新的挑战想要寻求新的体验。那张照片也是为了纪念自己的一个结束以及寻找下一个开始。 不打篮球该选择什么作为新的作为新的运动呢，想起上次在学校玩的滑板，觉得挺难的，摔了很多次都没能掌握到那个平衡点，一旦速度上去之后就往后摔倒。但看别人能够玩的那么好，那么顺畅，就觉得特别舒服，而且觉得这是一个特别酷的运动，就一个人在那里玩，不用去理会周围人的眼光，一种天涯任我行的感觉。所以最终决定玩滑板。既然决定好了，那么就是实施的过程了，查到了号称上海最大的滑板店铺聚点滑板，就开心的跑过去了 (๑¯∀¯๑) 那是一个地下室，坐落在常熟路，从学校过去大概要花一个多小时，那个地下室要拐好几个路口才能顺利走到目的地，但是进去的路口不会让你觉得很单调，周围都有图案让你觉得来对了地方，走过最后一个路标终于看到了目的地。(｡◕ˇ∀ˇ◕) 还没进入店铺就是琳琅满目的滑板，ヽ(￣▽￣)ﾉ。其实我有些担心会找不到自己喜欢的板面，但是还是细心的去浏览每一个滑板，希望找到自己心仪的那块板。进来没看多久，热情的老板就上来询问，知道我是初学者然后就开始给我介绍两种板，一种是代步类型，一种是带一些技术的板，作为一个有一丢丢梦想的萌新，当然不能选择代步式啦，果断选择了第二种。第二种的话，可以选择组装类别的也可以选择已经是成品的。组装的好处是可以自己DIY，但价格会稍微贵一些，成品的话就会选择的空间很小，板面也是只能选择现有的那些。思考了一会儿，我觉得还是选择组装的吧，毕竟后续想再倒腾也可以再在原有的基础上改装嘛，只要价格不要太夸张就没问题。 既然选择了组装，就要开始选择一个板面，然后就是轮子类型和轴承类型，这是主要的东西，我选择了我比较喜欢的板面，然后后面的轮子以及轴承都是选择差不多店里最便宜的产品，毕竟作为学生党来说经济能力有限，而且对于一个菜鸡来说硬件上的区别影响微乎其微，所以想着能少则少。想起自己昨天还网购了一批东西，心想这个月肯定是要勒紧裤腰带过日子了。 (〃´皿`) em……少吃点少花点没事，反正也饿不死…开心的是自己终于组装好自己的第一块滑板了，duangduangduan！！！ 感觉玩滑板不仅是对自己技术上的挑战，更多对于自己而言会是心理上的挑战，祝自己玩的嗨皮啦啦啦 =.=","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"SPORTS","slug":"SPORTS","permalink":"http://swcheng.com/tags/SPORTS/"}]},{"title":"找回走失的童心","slug":"找回走失的童心","date":"2019-02-03T13:41:00.000Z","updated":"2019-05-19T09:42:05.865Z","comments":true,"path":"2019/02/03/找回走失的童心/","link":"","permalink":"http://swcheng.com/2019/02/03/找回走失的童心/","excerpt":"前几天无聊的时候到小学附近逛了逛，小学附近很多东西都变了，但看到那熟悉的小摊，自己感觉仿佛好像回到了那个时候，那个每天都会在小摊寻找自己喜欢的东西的小时候。学校的每一个角落都充斥着快乐的记忆，只需要看一眼就能想起那时候在这个地方做过什么。小时候，每次放学回家都不会想要回家，快乐的是和小伙伴每次都选择试试看能不能走不同的路回家，好奇的探索每条路上的一切，感觉自己只要看一眼某个方向就能想起那时候在路上的快乐回忆，每条路都知道会通往哪里，美好的童年~","text":"前几天无聊的时候到小学附近逛了逛，小学附近很多东西都变了，但看到那熟悉的小摊，自己感觉仿佛好像回到了那个时候，那个每天都会在小摊寻找自己喜欢的东西的小时候。学校的每一个角落都充斥着快乐的记忆，只需要看一眼就能想起那时候在这个地方做过什么。小时候，每次放学回家都不会想要回家，快乐的是和小伙伴每次都选择试试看能不能走不同的路回家，好奇的探索每条路上的一切，感觉自己只要看一眼某个方向就能想起那时候在路上的快乐回忆，每条路都知道会通往哪里，美好的童年~ 小时候有太多太多的记忆，那时候对任何事儿都充满好奇心，那时候什么事情都会想要去尝试，那时候觉得任何一件小事都会觉得特别开心，抓一只蝗虫、在田里抓鱼回去养着、在一个废弃的水芯笔的收集堆里仔细寻找还能够使用的水笔、在回家的下坡尽情的冲刺、和小伙伴比谁先到学校而快乐轻盈的奔跑、为收集108将的卡片而疯狂的买方便面……想到这里，忍不住给儿时的小伙伴打了个电话，问问他是否家还住在原来的地方，hhh，电话接通，人家还没起床，约好在小时候那个熟悉的加油站见面。然后就到他家坐坐，就像小时候那样，经常会到他家那里去玩，聊了聊小时候发生的事儿，都觉得小时候的快乐特别简单，感慨现在想要获得快乐怎么越来越难，我还用我们专业课老师喜欢给我们说的一句话自嘲现在的状态，”没目标的时候觉得特别无聊，有目标但又达不到的时候觉得特别痛苦，人生真的是在痛苦和无聊中摇摆”。听完真觉得有点想笑，只是当时不知道为什么会这样。 好像一直被时间着急推着往前走，不断会有人告诉你，为了未来应该怎样怎样去做，什么是黑什么是白，什么是对什么是错，可从来没有人会告诉你说，从来没有那么纯白或者纯黑的颜色，生活本应该是黑白掺杂的灰色，即使是纯白的东西，也是需要与黑色互相衬托才能够显示出它的精彩。从来没有人问过自己到底喜欢什么，好像喜不喜欢没那么重要，心中的感受也不重要，所有一切只不过是为了那个还没到来的未来，没有对未来产生感受，就已经逐渐习惯了变得接受看似约定俗成的东西，习惯忍耐乏味，习惯为了未来妥协去做自己不喜欢的事情，习惯了被规则指引限制了思维。其实真的不需要去恐惧未来，也不用刻意去为未来担心，别太着急给自己太多包袱，应该多给自己一点时间去感受去比较去领悟，去体会甚至是大家看来是错的东西，跌倒的时候也能够哈哈一笑站起来继续往前走。保持良好的心态，即使短时间目标无法达成也总可以达到目标，只不过是慢一点而已，用一个乐观的态度去面对生活，尽力完成自己工作的职责，业余时间可以培养自己的爱好，尝试不同的事情，跟随自己的好奇心，探索自己想要探索的事情，用心去体会生活，而不要使用一成不变的态度去看待生活，最重要的是，保持那份孩子一般容易快乐的心情，即使犯错也能够做到毫不在意，依旧可以开心的做到重新来过。 可能有的人会说，人长大了，就应该变得怎样怎样，小时候喜欢的东西太过幼稚那时候喜欢不过是还小，长大了自然就该放弃那些现在看来十分幼稚的事情。我觉得在生活中，随着年龄的增长，依旧还能够保持那颗容易快乐的童心的人确实是比较少。前几天到曾经的高中校园去逛，本来以为我们进不去，打算买一包烟，偷偷塞给保安大哥然后混进去 (￣▽￣)／。可没想到，去的那天他们刚刚放假，就很顺利的进去了。那天天气也是特别的好，在校园里逛来逛去打算回去的时候，那时候大家都放学回家了，但在学校食堂后面碰到一个独自玩滑板的女孩子，觉得很特别，和朋友商量了一下就过去和对方打招呼，还让对方教我们玩滑板 (￣▽￣)~* 。后来玩了一会儿滑板之后还聊了一会儿天，那个女孩让我印象感觉到很深刻的一些话是这样的，”我觉得他们好像在逼着自己成长这样”，我当时和朋友对这个话的理解可能都没到她这样说的含义，我朋友觉得是因为现在的学习把人逼得太快，其实没有必要，就像一个跑步，你慢一点走其实最后也能走到。我的理解是面对学习未来的压力过于大，逼着自己去接受一些规则从而去做一些事情。还有印象比较深的是我问她说你喜欢玩滑板，又是一个女孩子，担心别人会用不一样的眼光看你吗?记得她当时的回答是这样的，”那别人说什么其实只是他们会那么说，就像现在微博上对于一些事情很多人都有不同的想法，但是过一阵子他们可能又不会在意了”。她的话语真让我感到吃惊，我觉得自己在她这个年龄真的做不到她这样的思考。我之后又问了一个问题，大概意思就是你会不会为了自己喜欢的东西去疯狂的追求，记得她是这样回答的，”但现在的事情也要做好呀，做好了当前的事情才能够去做那些喜欢的事情”。朋友说和她聊天有种自己老了的感觉，我没他那么明显的感受，但觉得自己好像也变得不如像她一样单纯只是为了玩儿去做一些事情，做事情似乎更加在意目的和结果，在乎输赢，大概这也是老了的结果 (ー`´ー)。 写到这里，其实能理解的人也能够明白了，不能明白的大概就不会明白吧。恩，回到这篇文章的主题，找回走失的童心，记得我初中给自己起了个QQ昵称叫”我是奥特曼”，然后还是一个奥特曼的头像，hhhh，幻想自己是奥特曼简直不能太萌，小时候自己最喜欢摆的POS好像也是奥特曼的放大招的姿势hhh，真的很怀念那真正属于儿童时期的自己呀。 黑多一点也好，白多一些也没什么关系。无论是黑还是白都要自己去写，不要做被动物园管理员驯服的动物，而要去做自己的奥特曼，怪兽什么的，被打倒了，爬起来再打就是，实在打不过，回去补个能量下次再来，两次不行就三次，实在打不过就叫兄弟，就没有被怪兽吓倒过的奥特曼。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"Every story has an ending","slug":"Every story has an ending","date":"2019-01-26T16:29:00.000Z","updated":"2019-05-19T09:42:05.859Z","comments":true,"path":"2019/01/27/Every story has an ending/","link":"","permalink":"http://swcheng.com/2019/01/27/Every story has an ending/","excerpt":"现在是27号凌晨十二点半，耳机里播放着金玟岐的《惊天动地》，不禁勾起了自己的一些回忆，让自己想到了那段自己一直无法摆脱失败的感情所带来的痛苦情绪的日子。思考了一会儿，对于自身感情的事情其实自己一直不太愿意拿到一个公开的地方去说，自己觉得这算是一个比较私密的一个话题，只是觉得自己体会就行了。想想自己一天如果失去记忆，还能通过文字了解自己以前做了什么。最后还是想客观的面对这件事情，故而还是决定将这件对自己很特别的一件事记录到博客。","text":"现在是27号凌晨十二点半，耳机里播放着金玟岐的《惊天动地》，不禁勾起了自己的一些回忆，让自己想到了那段自己一直无法摆脱失败的感情所带来的痛苦情绪的日子。思考了一会儿，对于自身感情的事情其实自己一直不太愿意拿到一个公开的地方去说，自己觉得这算是一个比较私密的一个话题，只是觉得自己体会就行了。想想自己一天如果失去记忆，还能通过文字了解自己以前做了什么。最后还是想客观的面对这件事情，故而还是决定将这件对自己很特别的一件事记录到博客。 2019-1-25，对于我来说是一个特殊的日子，因为这一天自己选择彻底与她告别，那天晚上自己感到特别孤独和抑郁，和朋友一直保持电话，没有特别想说的话，就是不说话也不想对方挂电话，就是不想自己一个人呆着，觉得对方不挂电话就像是有一个人在自己身旁，那个电话持续了51分38秒，直到自己感觉到好一点才挂掉了电话，真的很感谢。不出意外的那个晚上自己躺在床上但一个晚上都没有睡着过，或许是悲伤的情绪充斥着自己的大脑，所以才会一直睡不着吧。想过给她发消息但又被理智拉住，该说的已经说的十分清楚，已经没有必要再去解释什么或是问候关心什么，因为既然决定想让这件事情彻底翻篇就以后不会给主动给她发任何消息了，这应该是需要遵守的最基本的原则了吧，也是我们双方最后的默契。 和她从初中开始当同学到现在大学快结束我和她已经认识了十年了，但也仅仅是认识十年而已，其实彼此真正接触了解的时间并不多，仔细思考起来也只有高中时候的QQ聊天，以及高三第二个学期的恋爱到分手，大学之后也只是偶尔聊天而已。直至现在，觉得自己对于她才开始可以说有了一定的了解。说来实在讽刺，开始有所了解的时候却是故事的结局。陈奕迅一首十年，让我不禁在想，十年之后，彼此会是什么样子，到时候应该都有了各自的家庭，那时应该生活中的各种事情会接踵不断，即使会想起今天的事情来，也应该会是一笑置之后继续各自的生活吧。 自己对她的感觉，虽然一直口口声声的说着自己喜欢对方，但要问我到底喜欢对方哪一点，自己真的说不上来。但是见面聊天之后，当一切都尘埃落定之后，再去思考这个问题我觉得可以给出自己答案了。以前自己认为的喜欢是每次会见到对方的紧张的情绪，对对方的好奇，到了现在，能够用理智成熟的态度去面对对方之后，去说喜欢对方变成了保护自己的护具，也可以说是为了给自己的一种心理慰藉，或者说是一种对于她的一种虚无不切实的执念，当初喜欢的感觉其实早已经不复存在，看着坐在对面的人，内心不知为何真的很难再起半点波澜，但还是想要不断给自己灌输自己仍然喜欢对面坐着的那个人，看来自己对于她的执念不是一般的重呀，不然也不会在今年被这件事情困扰这么长时间。其实时间过去太长，中间彼此存在太长的空白期，大部分人都不可能对一个好长时间基本不怎么见面的人产生太多的感觉。 有时候我会问自己，到底什么是爱，自己想不出一个答案，就开始问自己的一些朋友，第一个朋友说他觉得爱是一种羁绊，当时我理解他指的是对对方的一种牵挂，但对方说这只是一部分吧。问了另外一个朋友，他说他觉得是每次和对方吵架那种想哭的心情，或者说是那种心痛的心情。问了我的表弟，表弟说他觉得是那种每次吃到好吃的东西，或是快乐的东西想要和对方分享的感觉，也会想要替双方的未来去做一些努力和改变。但是我问到一些年长的家人的时候，他们的答案就很统一了，他们觉得双方结婚在一起组建一个家庭最重要的都是双方互相理解，互相帮助，容忍，宽容。当我问自己这个问题的时候，我也在想对于我来说爱到底是什么，我个人所理解的爱是不计后果、不计回报站在对方的立场上想要对对方好的那种最质朴的感觉，即使自己失去一些东西也毫不在乎，任何行为和感觉都是很自然的，而不是带有目的的刻意讨好对方达到自己的目的去做的一些事情。 高三是我的思想变化最大的一个时期，那时候碰到了对影响自己最大的一个朋友，也是现在我最好的朋友，当时自己的思想比较容易受到书本的影响，那时候看了许多书，吸取到了不同的作家的思想，发现他们对于人生的见解和态度让当时还处于高三以为高考是自己人生最重要的一件事情的我感到新奇，感到佩服，知道世界上还有另外一群人，一群追求自由、真理、独立而不会循规守矩去干任何事情的人，一群只会听从自己坚持的东西的不畏强权的人，那时候有段时间自己还看林清玄，被他所说的人生无常的文章影响到自己有段时间觉得好像做什么事情都没有意义，╮(╯﹏╰）╭，现在想想以前还是太容易受其它思维影响，这种人生无常的观点还是只是听听就好，代入就不要了，还是要用正常的心态看待所谓的世事无常。那时候还不了解自己想成为什么样的一个人，自己到底是什么样的一个人，但很庆幸有了这些书的陪伴，至少让我有了敢变的不一样的勇气，也让我体验到了很多不一样的东西。到现在自己也越来越清楚自己到底是什么样的一个人，会和什么样的人能够志趣相投，会对什么样的人感到不屑一顾，自己的个性如此鲜明，却直至现在自己才了解到自己的这个特点，记得高中班主任也曾对我说过，”你其实就是个性太强，其它的没有什么。”。但这话我当时还不太能体会，直到我发现喜欢接触的人大部分都是个性比较鲜明的人之后，才能慢慢理解班主任说过的话，个性太强在班级可就是老师眼中的捣乱分子，难怪班主任对我这点不满意。 &lt;(￣ ﹌ ￣)&gt; 到了大学之后，自己的这个特点就开始全部显现出来，大概是大学氛围比较轻松，没有了父母的管束，老师的督促，自己就开始完全想干什么就干什么，所以大一第一个学期还挂了两门课，考工图完全不会，线性代数五分钟交卷，高数完全啃老本过考试，其它选修课虽然没过但是分数也是很低。自己也开始反思自己太过自我的方式的问题所在，选择开始慢慢的对浮躁的自己进行一点点的沉淀，那时候碰到了大学影响我最大的物理老师，真的是觉得大物老师是用耐心和爱来教导我这种爱逃课的学生，从大物老师身上我也开始认识到自己确实是太过于浮躁，这样下去什么事情都会干不好，于是从那时起决心彻底改变自己。自认为直到现在我依然很多时候会很浮躁，但是比起自己刚开始进入大学的那段时间进步实在是要大太多。 从和她谈到大学快结束，我已经与高中那个自己已经大有不同，发现这些的时候，对于爱情的问题也从之前的腼腆变得尖锐，这也是自己最自然的状态，不会去害怕失去，不会害怕自己不够好，所以我会和将所有问题都和对方聊清楚，拒绝和她开始慢慢去试探对方看是否合适自己，因为自己内心对待爱情的态度是不容许在开始自己被当做一个挑选品的，我也不喜欢在爱情中存在中间地带，因为我足够确定自己的想法，我也希望对方对于自己能够多一些确定，而不是使用试试看合不合适的态度。即使双方在很长时间不联系之后对彼此有很大的陌生感，但在认真沟通之后，我认为确定能够值得去爱的人就应该大胆放手去爱，如果这个都不能确定而非得要先试试合不合自己的味口，说明对方根本不能够确定自己的情感，但这对于一个未来会存在很多其它问题的恋爱来说，这样的不确定肯定是致命的，如果要以这样的方式继续去发展，肯定是未来浪费彼此的感情和时间罢了。所以我觉得很多话都已经说的足够清楚，如果对方却不能够理解还一直在思考不确定是否合适的话，那么就没有继续谈的必要了，不如当断则断。 其实说了这么多，和她聊天之后真的是认为两个人现在已经很难走到一起了，其实聊的过程自己已经知道那天的结局，但还是想要尽最大的努力，这样无论如何自己总是尽力了，这样自己才能让自己不带后悔的勇敢去面对结果。这样用力的去做这样一件事情之后，明白对方已经彻底不再是自己寻找的人，自己对于她的执念也从此消失，也是对于这件事的划上一个休止符，同时对于自己来说，终于能够彻底放下过去，真的向着未来迈开大步，能够真正向下一个开始做到义无反顾。 有时候我在想爱情也好，婚姻也好，对于自己到底意味着什么，到底是钱钟书写的围城，城里的人想往外走城外的人拼了命想要进去，还是陈奕迅唱的红玫瑰的歌词，那个红，会是短暂的红色浪漫玫瑰之后如蚊子血一样平庸吗，会只是得不到的永远在骚动而已吗。这些东西似乎是任何关系逃不开的话题，但是我依然会相信明天会依然很好，相信自己未来可以将自己的感情处理的很好，不必刻意将这些消极情绪放在心上，未来就算是再大的挑战，我也会选择不退缩的继续走下去。 最后想要使用我最喜欢的女歌手的一句话作为结束: “理智与疯狂，我选择并行” -孙燕姿 《跳舞的梵谷》 swcheng 2019-1-27 5:07","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"EMOTION","slug":"EMOTION","permalink":"http://swcheng.com/tags/EMOTION/"}]},{"title":"Summarize_2018","slug":"Summarize_2018","date":"2018-12-30T12:48:00.000Z","updated":"2019-05-19T09:42:05.860Z","comments":true,"path":"2018/12/30/Summarize_2018/","link":"","permalink":"http://swcheng.com/2018/12/30/Summarize_2018/","excerpt":"哇，时间过得好快呀，又要过年啦。ヾ(๑╹◡╹)ﾉ” 最近心情总是起伏不定，生活作息时间也失去规律，今天终于平复下来了，所以打算将2018年发生的事情进行一个回顾以及总结。自己从小学开始的时候最喜欢做的事情是玩游戏，但自从游戏玩的少之后，我发现自己最大的爱好似乎变成了记录。(￣∇￣) 大概是觉得记录才能展现一件事情的全貌，不想要错过任何一个细节。要是活在古代估计我可能会想要去当个史官什么的吧hhh，说到这个，其实自己有时候会想到如果不选择计算机我会选择什么样的职业，我觉得如果以现在的想法来看，自己多半不太可能继续选择理科，会想去从事与艺术相关的东西吧，也会想当歌手，但自己唱歌水平实在是hhh，不说了，想法虽然天马行空，但自认为我还是一个现实主义者，只能向理想主义者投去羡慕的眼光啦。","text":"哇，时间过得好快呀，又要过年啦。ヾ(๑╹◡╹)ﾉ” 最近心情总是起伏不定，生活作息时间也失去规律，今天终于平复下来了，所以打算将2018年发生的事情进行一个回顾以及总结。自己从小学开始的时候最喜欢做的事情是玩游戏，但自从游戏玩的少之后，我发现自己最大的爱好似乎变成了记录。(￣∇￣) 大概是觉得记录才能展现一件事情的全貌，不想要错过任何一个细节。要是活在古代估计我可能会想要去当个史官什么的吧hhh，说到这个，其实自己有时候会想到如果不选择计算机我会选择什么样的职业，我觉得如果以现在的想法来看，自己多半不太可能继续选择理科，会想去从事与艺术相关的东西吧，也会想当歌手，但自己唱歌水平实在是hhh，不说了，想法虽然天马行空，但自认为我还是一个现实主义者，只能向理想主义者投去羡慕的眼光啦。 人生天地之间，若白驹过隙，忽然而已 这句话出自《庄子》，大概也是生活的真实写照吧，不知不觉自己的大学生涯就要结束，其实也没什么好感叹的，时间不就是这样，一直无形之中推着人往前走吗，有的人可能觉得大学没做什么事会有什么遗憾之类的，可能对于大多数人来说最多的回答会是大学没谈恋爱会遗憾之类的，当然对于不同的人来说也会有各种各样的答案，对于我自己来说，大部分时间是和计算机其次就是篮球度过的，至于大学没谈恋爱会不会有遗憾，虽然有时候会有些失落，看到人家结对而行，自己总是形单影只，也会感到很孤独，但回顾自己的大部分时间其实还是比较充实的度过的，我个人对于遗憾的定义不是没有在合适的时间没有去做合适的事情，而是在自己在做某件事情的时候，自己没能够将它做到令自己满意的地步，所以我自己大学的遗憾不是自己大学没谈恋爱或是其它什么想做却没做的事情，而是发现自己太多缺点，太多事情没有做的足够好，很多事情都是有始无终。 回到正题，2018，发生了很多事情，从年初决定考研，到放弃考研决定工作，哦对了，还有一件很值得说的是到她家楼下喊她的名字，哈哈哈真佩服当时自己的勇气，其实我本质上是属于比较内向的人，这样的事估计对于我来说也不会存在下一次了，从和室友参加华为杯到中途放弃决定将时间投入在参加导师推荐的TI杯，到最后对TI杯的放弃，买了一堆电子元器件，最后啥也没干。去绍兴旅游了一次，学习JS，学习Node, 学习MongoDB, 搭建博客，面试，实习，学了一点Vue，准备毕设题目，辞职，学习Python，学习Scrapy…恩，差不多就这样。感觉大部分都是有关学习的事，(艹皿艹),所以说这大概就是作为单身狗的基本修养吧。 年初的时候决定考研，当初自己想的是考研会有很多奖学金就不用再问家里伸手要钱了，而且会有更多自由的时间让我学更多的知识。当时想报考华南理工，想考华南理工的原因一是广州离家比较近，所以以后回家也方便，二是学校也不错。但之后放弃的原因一是因为之前只写过Android，所以自己一来想参加竞赛做一些东西，并且当时又想打开Web开发的神秘大门，但考研就意味着自己要重新开始面对自己极为讨厌的不断重复刷题的生活，让自己做感到痛苦的事情实在是太难了，经过挣扎之后意识到自己就应该直接去做自己当前最想去做的事情，而不是学会向自己不喜欢的东西妥协，如果能学会妥协，那也就不是我自己了，失去了自我，活着也没太大意思。虽然考研是个很不错的选择，但确实不适合自己，放弃了考研，打算参加比赛，动手去做一些东西自己还是比较感兴趣的。 当时已经答应室友参加华为杯，并且已经开始了一段时间了，但是之后导师又叫我参加TI杯，我就和导师说了我已经答应别人了，不能背弃承诺去参加另外一个比赛。导师劝说我应该把TI杯的优先级放在前，所以不得已只得和室友说明情况就是华为杯的事情不能参加只能你独自作战了。(我当时被导师劝了一会儿就直接放弃了答应室友的事情，现在反思这样做其实是有很大问题的，答应过别人的事情就应该尽全力去做到，要不然就不要答应别人，即使导师劝我，我也应该继续坚持自己的立场) 之后为了报名参加比赛，导师叫我组织几个人一起参加这个物联网比赛”TI杯”，之前我们学校还没有人参加过这个比赛，自己对嵌入式的东西了解很少，我跑了好几个宿舍，去找了一些自己觉得能干事情比较靠谱的人，话说被拒绝的滋味还真不好受呀，尤其是你去找到别人用很诚恳的态度问别人介绍这个比赛，然后阐述自己的想法，询问对方对这个比赛有没有兴趣，有的人却用一种自以为自己很了不起的态度对着你，一幅爱理不理的态度，换谁心情都好不起来了吧，虽然自己遭受到了不好的态度，在前后跑了几次之后总算是将人凑齐了，还是找到了自认为靠谱的人。接下来就是大家开会商讨做一个什么作品参加比赛，经过几次讨论将题目定下来了，我向老师提出我们需要一个实验室，因为没有实验室的话，我们在宿舍弄这个关于硬件方面的东西实在是不太方便，去图书馆的话也不太合适，毕竟大家要在一起合作做一个东西，需要一个实验室大家随时有事情可以进行商讨，也可以及时了解事情的进度等等。老师当时也答应了，说帮我们弄一个实验室，但要过几天才给我们回复。我想，等几天就等几天吧，我就把电子元器件都买好了，也烧写上了Android Things的硬件开发环境，并还写了一个通过代码控制小灯亮和熄的demo,就等着老师什么时候给我们回复。但是等呀等，就是没能等到对方给自己答复，说实话，此刻我的心情有点糟糕，当时心里想你找到我和我说了这个比赛的事情，然后我为了这个比赛放弃另外一个比赛，之后又为了这个比赛主动去找了一些人，甚至后来你说现在好像不能买东西报销，要等一段时间才能报销，我就自掏腰包先买了一些需要用到的东西，最后要求一个实验室，这样重要的一件事根本就没有得到重视，当时说过答应的话似乎也是场面话，如果要我一直催这样一件事情我觉得这个比赛还不如不做，因为即使去做也是我自己一个人在自己瞎玩，最后无非是浪费自己的时间和精力。所以没有得到回复我就不理这个比赛了，之后过了不知多久时间他终于想起这件事情了，还问我们做的怎么样，我还得无奈的解释这个事情没法做。(不是事情没法做，而是心凉了什么事都做不了) 感觉怎么这个年度总结这么多消极情绪呢，人家年度结束的时候都是为明年设个什么小目标许个小愿啥的，我却在年度总结里写过去的一年里哪些事情让自己不舒服。(ㄒoㄒ)。希望自己不要再犯同样的错误了，以后无论什么事情在答应别人之前，自己首先应该考虑清楚，且和对方沟通清楚才行，从和对方的沟通中观察对方的态度和想法，一旦答应过的事情就一定无论如何要做到。一些原则性的东西面前一定不能让步。 关于比赛的事情告一段落，自己准备学习Web开发方面的知识，因为自己之前只写过Android，而Web的运用场景要比Android要广泛的多，如果自己不涉足这个方面的知识的话觉得自己就像…em…怎么描述…就是有一块你感兴趣的大陆…但不去探险的话实在是太可惜了。所以开始学习JS,并想通过搭建一个博客去锻炼提升自己在这方面的能力，但是博客搭建还没完成，学期就已经快要结束了，只能一边找工作一边继续了。之后就是准备面试，自己之前的面试十分不顺利，自己思考了一下失败的原因是，一是自己在面试方法上存在一些问题，二是对自己的定位不是特别明确，三是自己准备的不够充分。在对自己进行了一些调整之后，开始了新的面试，依稀记得自己在面试TD的时候，自己准备好自己要说的内容之后，并且也是按照我想要说的内容在表达，但是不知为什么我会很紧张，我觉得我不应该是容易紧张的人呀…总而言之那天虽然自己说了很多话，但是实在是紧张的不得了，说话的时候手一直在不停的哆嗦，对于面试官的提问自我觉得回答的还过得去，最后还得知面试官居然是自己的学长hhh。在顺利的找到了自己想要的Java Web开发实习之后，告知对方自己在学校的课程要在短学期结束之后才能去报道，之后就在短学期结束之后(七月二十三号)一直实习到十二月十二号。 实习中认识了一些新的人，用了自己没用过的IDEA作为新的开发工具，不过话说回来IDEA和Android Studio的使用方式其实十分相似，我没用多久时间就很快上手了，毕竟都是一个公司的产品，所以使用方式也十分相似，相比较Eclipse来说，IDEA要好用的太多，当然体积也重很多，很吃内存。但相对于其优点来说，这个还是可以接受的。连接数据库使用了我之前没有使用过的Navicat,不过Navicat还是蛮好用的，是一款十分优秀的工具。 对于这份实习，开始我是满怀着期待，因为这是自己的一份实习，并且是我想要做的工作，用职业的要求去要求自己，想要大展拳脚一番。到了项目组的第一天发现，一切并不是自己想象的那样，每个人上班能晚则晚，有事就做，没事儿就闲着干其它的事情，经常会聊一些生活中的各种琐事，感觉这完全不是自己所追求的地方，自己渴望的是特别有技术氛围的团队，每个人都拥有对技术的执着，会因为一个观点与你进行理性的争论，这才是自己理想的工作环境。看来理想毕竟还是理想呀，虽然不能实现，但我也会朝着这个方向去追求。虽然一来就对项目组印象就不是特别好，但是自己的初衷是来学习知识的，抱着学习的心态完成每一个mentor交给自己的任务，即使再难，我也会尽全力去弄明白，一时弄不明白就多花时间，直至将任务完成。所以自己保持这样的态度从开始进入到平台测试修改BUG到后来单独承担开发任务，不仅学习到了很多技术上的知识，也学会如何更好的和同事进行沟通交流解决问题，以及其它方面的提升等。 实习大部分时间过的比较充实，但还是决定离开这个地方，离开之前自己很纠结要不要参加这个公司的转正答辩，刚开始自己想要参加是因为考虑到自己万一明年找工作不顺利的话起码还手上还有一个offer，但最终我还是决定直接离职，连答辩都不想参加了。在将项目组交给我独立完成的模块开发任务完成的差不多之后，新任务也不打算继续做了，直接阐述了离职想法，并在当天离开项目组。这个项目组除了之前所说的氛围我不喜欢之外，真正让我决定义无反顾离开的还是项目组中有些人让我觉得没法忍受，也不想继续忍受与这样的人继续相处下去。原因这里就不阐述了，每个人都有自己的性格，有自己的脾气，选择隐忍不过是因为自己还有一些工作没有完成，而自己是一个比较负责的人，想做完交给我的工作之后再离开，如果当场翻脸以后如果和这样的人待在项目组会更加难受，所以在做完大部分交给自己的开发任务就义无反顾的离开了，我不能够忍受我厌恶的东西一直在自己身边环绕。或许自己以后在工作中还会碰到类似的人，或许以后不能像还是在学校这样可以任性的做自己想要做的选择，但是我觉得在我可以做选择的时候，就一定要做自己的选择，对于这种人我只想用一句话代替我的心情，”拉屎都要离他八丈远”。 我不是想抱怨什么，我也不是一个喜欢抱怨的人，在困难面前，我也从不喜欢退缩，更喜欢闭上嘴，硬气的去克服困难。但对于一些事情我持有自己的态度，不能接受的东西或者不认可的事情，就绝不会去做，也不会妥协，这是自己的个人喜好，也是我的态度，正因为这些，我才是我，不是其他任何人。 2018，在一年快要结束的十二月份，开始学习Python，学习爬虫框架，这段时间已经使用PyCharm编写了3,541行Python代码，但要完成自己的毕设还有很多工作要去做。在临近毕业的时候选择开始学习Python，是因为自己觉得未来一定是属于大数据的时代，通过数据去更好的了解过去发生的事情，甚至通过数据去预测未来，这才是最棒的事情，未来还有很长的路要走，为成为魔法师而努力吧。✧⁺⸜(●˙▾˙●)⸝⁺✧ 2018已悄然结束，对于即将到来的2019，希望自己能够调整好心态，给自己多一点耐心，明白专注的力量，不要为了速度而牺牲深度，多一点谦虚，多一点努力，所有学会的知识都是来自于他人的分享与无私贡献，自己也要学会乐于分享自己获取到的知识，最重要的是，无论怎样都要坚持自己选择的道路。","categories":[{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]},{"title":"抓取喜爱123音频文件","slug":"抓取喜爱123听故事音频文件","date":"2018-11-24T12:25:00.000Z","updated":"2019-05-19T09:42:05.867Z","comments":true,"path":"2018/11/24/抓取喜爱123听故事音频文件/","link":"","permalink":"http://swcheng.com/2018/11/24/抓取喜爱123听故事音频文件/","excerpt":"滴…你的表弟已上线，问你是否可以帮他把英语听力下载到他的MP3。(；′⌒`)…开始我以为他是不会如何将文件放在MP3的磁盘里面，就对他说将文件下载后放到移动磁盘就OK。然后他又说他老爸找不到下载地址，额….我心想下载地址你找不到我也没办法帮他去远程找下载地址呀…接着表弟就发了个微信分享的链接给我…但当时我不在宿舍，就说回去帮他看看。","text":"滴…你的表弟已上线，问你是否可以帮他把英语听力下载到他的MP3。(；′⌒`)…开始我以为他是不会如何将文件放在MP3的磁盘里面，就对他说将文件下载后放到移动磁盘就OK。然后他又说他老爸找不到下载地址，额….我心想下载地址你找不到我也没办法帮他去远程找下载地址呀…接着表弟就发了个微信分享的链接给我…但当时我不在宿舍，就说回去帮他看看。 回到宿舍已经是八点半，用电脑登录微信，打开表弟给的微信分享，其实就是使用微信的内置浏览器打开了一个地址。复制了链接地址改为使用Chrome打开，看到了下面的在线听听力的界面。 接下来把这个界面点了点，并没有发现听力的下载地址，看来是有意不提供下载地址，于是打开了调试模式查看网页对应的源码，想看看是否能在html界面中找到听力文件的地址，但是定位到对应的按钮点击的html代码，只看到了一个ul列表，里面的li标签只定义了一个class属性。看来音频地址是不会直接保存在html页面中的，(PS: 如果直接保存在html也太容易被获取到了吧) 于是接着查看它的源码。在chorme调试模式下定位到source tab页面，查看当前页面下的所有文件，显然我们的答案不可能存在css、img文件夹里，过滤掉css、img文件夹里的内容，仅关注js文件，下面两个文件出现在视野里: 那明显第一个是jquery在生产环境的名称，第二个文件叫smusic.min.js，里都有些什么内容呢?不妨打开看个究竟。这个js文件最外层是用一个 !function(l) {}(window); 包裹了一些方法的定义，一些变量的声明，但其中核心内容是设计者在其中定义了一个p对象，在js中对象的定义方式与函数声明的语法一样，区别定义一个函数还是一个对象取决于设计者使用它们的方式，如果定义的是一个对象，一般后续会使用 new xxx(…); 形式的语法去创建一个对象，而如果是作为方法调用则直接在js代码中使用 xxx(…); 形式的语法去执行调用。为什么说这个p是核心对象呢？原因是在对象p的prototype属性中定义了大量与播放音频文件相关的方法，这些方法包括 config、createListDom、setBuffer、resetPlayer、setVolume、initPlay、play、pause、getRandomIndex、playByMode、action、init ，顾名思义，init()方法中会执行一些初始化对象需要调用的方法和表达式，action()方法的内容是为不同的按钮添加点击事件，playByMode、play、pause、setVolume、resetPlayer则是与播放mp3音频操作相关的方法，config则是进行一些相关的配置…如果对这些方法具体的内容有兴趣，可以去仔细研究一下每一步它的执行，但在这里就不做过于详细的阐述了。 注意: js中没有java中的继承，它实现不同对象间共享变量、方法的方式是使用一个共享的原型对象，在这个原型对象中定义的方法和变量可以在任何一个通过其构造函数创建的对象中直接使用 !function(l) {}(window); 的作用与 (funcion(){})(); 一样，都是定义一个匿名函数接着进行对自身的调用，这种方式是在前面加上了!符号提示编译器这不是一个函数声明，而是一个表达式，从而实现与后者相同的效果。其它的运算符如 +、- 等也可以实现同样的作用，如果有兴趣可以研究一下它们之间的区别。 粗略的研究了一下 smusic.min.js 的内容，下一步就可以通过断点来追踪具体的执行过程了，我选择的是将这个断点打在了p对象的构造函数里面调用init()方法的地方，结果如下图所示，下图需要关注的地方被红圈标注出来了。 在对象p的构造函数中很容易可以注意到,为config进行了赋值，接着调用了原型对象中的init()方法。在这个构造函数中，很容易注意到musicList变量，可以将这个变量添加到watch里面追踪值的变化，然后可以看到其具体的内容，明显这里的musicList是一个数组，数组里的内容如下图所示: 显然这是一个json数组，里面的json对象包括了四个键值对，title、cover、singer、src，红色方框标注的内容是对应mp3文件的地址，这就是我们要寻找的东西啦。开始我的做法是在调试的时候直接将这个json数组里的内容copy到文件里，但是这样做会有一个问题，这个问题会导致我们拿不到正确的文件地址，原因是chrome在调试模式查看值的时候，如果一条记录的值过于长，不会显示所有的内容，而是会将结尾字符串的部分内容替换为…，但是我一开始并没有注意到这个问题，而是直接拿着这个url调用java的http api去下载，导致出现404错误，提示找不到对应的文件…刚开始我还以为这个站点做了安全措施…但是其实并没有…只是自己拿的方式有问题，正确的方式应该是使用JSON.stringify()将这个数组转为字符串，然后再存入到文件里。(当然也有将json字符串转换为对象的方法，需要使用JSON.parse()方法，注意参数需要使用单引号，因为json字符串的内容包含双引号，如果再使用双引号去包裹参数就会提示语法错误) 到了这里其实已经完成的差不多了，下面都是Java需要解决的问题了，由于存在172条记录，如果手动去提取地址再下载未免太麻烦，所以我的做法是使用Java的io流读取这个文件里的内容到一个StringBuffer对象中，当然也可以使用StringBuilder，这两个的主要区别是StringBuffer是线程安全，StringBuilder不是线程安全的。由于我使用的是单线程下载，所以无论是使用StringBuffer还是StringBuilder其实都一样。将文件的内容读取到StringBuffer对象中之后，就可以愉快的进行我们想要的操作了。将所有的地址提取出来可以使用Java里的正则表达式，其核心的两个对象是Pattern和Matcher。匹配方式有三种，分别是matches、lookingAt、find，这三种的区别是matches是用于匹配整个字符串，就是说需要pattern和输入的字符串完全相等的时候才会返回true。lookingAt方法会匹配输入字符串的开头，仅当输入的字符串的开头部分满足匹配模式的时候返回true。find方法会扫描整个输入字符串，并且是逐个寻找满足条件的匹配模式，直到找不到匹配的内容为止。在这个需求里，匹配需要的地址就很容易啦，字符串内容的开头一定是http://ting.xiai123.com/mp3/，结尾一定是.mp3，这样去编写匹配模式就Ok。将匹配到的所有的url存入一个字符串数组中，接下来就是逐个去下载的问题啦，这里就不一一介绍了，自己踩的一个坑是将地址进行URLEncoder的时候选择了全部的地址，其实只需要将结尾部分进行重新编码就ok了，但是使用Java调用URLEncoder.encode()方法还存在着一个问题就是空白符会被替换成+，正确的替换结果应该是%20，无奈自己只能再调用一个replaceAll方法去替换。 如果对这些代码有兴趣的话可以在这里下载，https://github.com/cheng-github/DataStructure_Java/tree/master/src/test/java/download。如果这个站点的源码有更多兴趣可以打一些断点，在Call Stack跟踪方法执行流程，以及Watch关键变量的值。 这个网站没有作任何的保护措施，但是我还是一直弄到晚上一点才搞定，同时自己也发现抓取一个站点的数据其实是特别有意思的，听说Python对此有更强大的支持，赶紧去了解一下。(*´ﾟ∀ﾟ｀)ﾉ End","categories":[{"name":"DATA SCRAPING","slug":"DATA-SCRAPING","permalink":"http://swcheng.com/categories/DATA-SCRAPING/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"求最大子序列和的四种实现方式","slug":"2018-11-19_最大子序列求和","date":"2018-11-18T08:20:00.000Z","updated":"2019-05-19T09:42:05.858Z","comments":true,"path":"2018/11/18/2018-11-19_最大子序列求和/","link":"","permalink":"http://swcheng.com/2018/11/18/2018-11-19_最大子序列求和/","excerpt":"在总结求最大子序列和的四种实现方式之前想谈谈为什么自己想要重新学习数据结构。之前在大二下学期的时候已经学过了数据结构这个课程，依稀记得老师一直提醒我们数据结构是计算机的核心课程，并且对于考研或者是找工作面试都是很重要的，特地提醒我们要重视这门课程，希望我们好好学习数据结构。当时自己在上数据结构这个课程之前已经使用过基本的数据结构-链表完成了大一下学期的一个C语言课程设计，记得那是自己使用C语言写的一个程序，虽然仅有一百多行，显示界面也只是一个小黑框，但完成的时候特别激动，因为那是自己真正意义上动手写的第一个完整程序。本来还想找到原来的代码运行一下，但发现自己前一段时间为了清理笔记本空间已经将自己之前写的关于C的代码都删除了 ╮(╯﹏╰）╭","text":"在总结求最大子序列和的四种实现方式之前想谈谈为什么自己想要重新学习数据结构。之前在大二下学期的时候已经学过了数据结构这个课程，依稀记得老师一直提醒我们数据结构是计算机的核心课程，并且对于考研或者是找工作面试都是很重要的，特地提醒我们要重视这门课程，希望我们好好学习数据结构。当时自己在上数据结构这个课程之前已经使用过基本的数据结构-链表完成了大一下学期的一个C语言课程设计，记得那是自己使用C语言写的一个程序，虽然仅有一百多行，显示界面也只是一个小黑框，但完成的时候特别激动，因为那是自己真正意义上动手写的第一个完整程序。本来还想找到原来的代码运行一下，但发现自己前一段时间为了清理笔记本空间已经将自己之前写的关于C的代码都删除了 ╮(╯﹏╰）╭ em….一个订餐管理程序，有显示当前订单列表、添加订餐信息、删除订餐信息、修改订餐信息、根据价格为订单排序、将已有订餐信息写入文件等几个简单的小功能，尤其是添加写入到文件这个模块的时候，自己遇到不知道如何解决的一个地方一直没法正常写入到文件，在CSDN上提问然后得到了一位前辈的指教才顺利的完成的这个功能，thanks ( • ̀ω•́ )✧ 。这个程序当时给老师展示之后最后拿了93分的成绩，自己对于成绩倒不是特别在意，但这也是老师对自己的一种认可吧，更让自己开心的是探索的过程。那是自己第一次接触数据结构，被链表折磨的死去活来，去图书馆借书学习链表，一本看不懂就再借另外一本，读了好几本不同书籍关于链表的内容才开始慢慢理解它，至今还能回忆起当初冥思苦想的那几天。(￣∇￣) 不知不觉又扯了这么远…回到正题，一个学期学习数据结构的时间肯定是不够的，更何况自己当时还并没有花特别多的时间去钻研数据结构，对于每种数据结构都仅仅是简单按照书上的例子实现了一遍，到了现在该忘都忘的差不多了…(╯︵╰) 但真正让我决定重新学习数据结构的原因不是自己想要温习知识，之前面试阿里的时候，面试结束的面试官问我有什么问题想要问他的，我觉得自己面试过程中回答的不好，所以就问面试官对于自己的学习有什么建议没有。面试官就说，培养一个掌握基本开发技能的普通程序员很容易，但数据结构是十分重要的，理解技术的原理也是十分重要的，还讲violate的原理给我听。加上之前在公司的季度技术交流会上，看见某位大佬秀了一波关于数据库方面的数据结构的知识，当时自己真是热血沸腾的感觉，并且那一刻真正的意识到是时候该找时间好好的学习数据结构了，于是才选择了《数据结构与算法分析 Java语言描述》-Mark Allen Weiss这本书，并计划一边学习这本书一边写博客记录学习过的内容。最后说一下自己的粗见吧，数据结构可能暂时在开发小型程序的作用还不是特别明显，搭建好开发环境之后，只要对某种语言比较熟练就可以做到业务上的实现，但是如果涉及到大型的应用的构建，当应用吞吐量很大的时候，一个小的细节对于应用整体的性能的作用就会比较明显了，这时候我们不仅需要了解使用到的技术的原理，而且需要更有技巧的编程，用更少的执行时间去完成相同的任务，相反而不是去粗暴的使用蛮力算法实现需求。所以从长远的角度来看，熟练掌握数据结构是十分必要的。 最大子序列和，就是指在一个元素类型为整型的数组中，求其中连续的一个序列和的最大值，这个序列的开始下标可以是数组中的任意位置。如果我们按照列举所有可能情况的思考方式编写代码: 第一种方式 123456789101112131415161718192021222324252627282930public static void main(String[] args)&#123; int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; System.out.println(maxSubSum1(a));&#125;/** * 最大子序列和,最简单直接的求最大子序和 * @return */private static int maxSubSum1(int[] a)&#123; int maxSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = i; j &lt; a.length; j++) &#123; int thisSum = 0; for (int k = i; k &lt;= j; k++) &#123; thisSum += a[k]; &#125; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; &#125; &#125; return maxSum;&#125;/* 输出结果: 50*/ 很明显，这里的最大子序列和为前五个元素的和。下面我们分析一下该算法的时间复杂度。假设我们输入的数组的长度为N，忽略声明、调用方法、返回值的开销，仅关注嵌套的for循环所占用的时间，那么所耗费的时间为: $ \\displaystyle \\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^j1 $ 对该表达式从里到外求和: \\displaystyle \\sum_{ k=i }^j1=j-i+1 继续从里往外求和: \\displaystyle \\sum_{ j=i }^{ N-1 }( j-i+1 )=\\dfrac{( N-i+1 )( N-i )}{2} 所以有: $ \\displaystyle \\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^j1 $ = $ \\displaystyle \\sum_{ i=0 }^{ N-1 }{\\dfrac{( N-i+1 )( N-i )}{2}} $ = $ \\displaystyle \\sum_{ i=1 }^{ N }{\\dfrac{( N-i+2 )( N-i+1 )}{2}} $ = $ \\displaystyle \\sum_{ i=1 }^{ N }{ ( \\dfrac{i^2}{2} - \\dfrac{ 3i + 2iN }{ 2 } + \\dfrac{N^2 + 3N + 2 }{ 2 } ) } $ = $ \\displaystyle \\dfrac12 \\sum_{ i=1 }^{ N }{ i^2 } - (\\dfrac{ 3+2N }{ 2 })\\sum_{ i=1 }^{ N }{ i } + (\\dfrac{N^2 + 3N + 2}{ 2 })\\sum_{ i=1 }^{ N }{ 1 } $ = $ \\displaystyle \\dfrac12 \\dfrac{ N(N+1)(N+2) }{6} - (\\dfrac{ 3+2N }{ 2 })\\dfrac{ N(N+1) }{2} + \\dfrac{N^2 + 3N + 2}{ 2 }N $ = $ \\displaystyle \\dfrac{ N(N+1)(N+2) }{ 6 } $ 经计算可知该算法的时间复杂度为$ O(N^3) $，其实我们没有必要通过三层的for循环穷举所有的子序列的和，上面的第三层的for循环的计算明显存在冗余，仅仅两个for循环就可以满足求和需求: 第二种方式 12345678910111213141516171819202122public static void main(String[] args)&#123; int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; System.out.println(maxSubSum2(a));&#125;private static int maxSubSum2(int[] a)&#123; int maxSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; int thisSum = 0; for (int j = i; j &lt; a.length; j++) &#123; thisSum += a[j]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; &#125; &#125; return maxSum;&#125;/* 输出结果: 50*/ 仅关注嵌套的for循环所占用的时间，那么所耗费的时间最多为: $ \\displaystyle \\sum_{ i=0 }^{ N-1 } \\sum_{ j=i }^{ N-1 }3 $ 对该表达式从里到外进行求和计算: $ \\displaystyle \\sum_{ i=0 }^{ N-1 } \\sum_{ j=i }^{ N-1 }3 $ = $ \\displaystyle 3\\sum_{ i=0 }^{ N-1 }(N-i) $ = $ \\displaystyle 3\\sum_{ i=1 }^{ N }( N-i+1 ) $ = $ \\displaystyle \\dfrac{ 3N(N+1) }{ 2 } $ 计算知第二种方法的时间复杂度为$ O(N^2) $。第二种方式避免了单独计算每个子序列结果的值，在第一种方式里，当第二层循环的j取最大值的时候，最里面的循环累加的结果包含了j取其它值的情况。而第二种方式正好避免这种冗余的计算，将每次累加的结果与当前最大的结果对比，从而降低了时间复杂度。以为这就是最优秀的方法了吗？然而编程思想的威力远没有这么简单，第三种方式采用了在算法设计中普遍采用的一种方式-“分而治之”: 第三种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args)&#123;// int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; int[] a = new int[]&#123;-11, -21, -5, -11, -42&#125;; System.out.println(maxSubSum3(a, 0, a.length - 1));&#125;/** * 最大子序列和 第三种方式 * @param a * @return */private static int maxSubSum3(int[] a,int left,int right)&#123; // 对于递归方法总会有一个基准情况，这里的left与right相等的时候就是我们这里例子的基准 if( left == right )&#123; if( a[ left ] &gt; 0) return a[ left ]; else return 0; &#125; int center = (left + right) / 2; int maxLeftSum = maxSubSum3(a, left, center); int maxRightSum = maxSubSum3(a, center + 1, right); int maxLeftBorderSum = 0, leftBorderSum = 0; for (int i = center; i &gt;= left; i--) &#123; leftBorderSum += a[ i ]; if( leftBorderSum &gt; maxLeftBorderSum)&#123; maxLeftBorderSum = leftBorderSum; &#125; &#125; int maxRightBorderSum = 0, rightBorderSum = 0; for (int i = center + 1; i &lt;= right; i++) &#123; rightBorderSum += a[ i ]; if(rightBorderSum &gt; maxRightBorderSum)&#123; maxRightBorderSum = rightBorderSum; &#125; &#125; return max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);&#125;private static int max3(int a,int b,int c)&#123; if (b &gt; a || c &gt; a)&#123; if(b &gt; c) return b; else return c; &#125; else &#123; return a; &#125;&#125; 显然第三种方式的代码要比前两种复杂，但是复杂不是出发点，我们的目的是减少时间复杂度。在第三种方式中，核心方法是int maxSubSum3(int[] a,int left,int right)，递归方法往往都存在着一个基准情况，不然递归就会无限循环调用下去，程序也毫无意义了。在这里15-20行是这个递归方法的基准情况，方法中的23、24行中进行了对自身的调用。接下来分析这个代码是如何执行的，为了更清楚该代码的执行过程，我调试程序的时候特意注释掉了main方法之前在第一种方式和第二种方式使用到的参数，使用数量较少的参数去还原该算法整个过程。方法中有三个参数，int[] a、int left、int right，第一次传递到该方法中的实参是数组a的起始下标和结束下标，显然第一次调用该方法是不满足基准情况的，在不满足基准情况下继续往下执行，计算left和right的平均值，如果不能整除则取去掉小数位的数值。然后分别将center作为right的实参传递到maxSubSum3()为maxLeftSum赋值，center+1作为left的实参传递到maxSubSum3()为maxRightSum赋值。顾名思义，maxLeftSum和maxRightSum其实就是将数组分为左右两块之后左右两个数组的最大子序列和的值。但是我们怎么知道这两个变量的值是左右两个数组的最大子序列和的值呢？仅从外层去理解这个程序是无法得出这个结论的，我们不妨追溯到该程序的基准情况，left=right。 当left与right相等的时候，程序会判断数组对应left的索引下标的值是否大于0，如果大于0，则返回对应值，小于0则返回0。显然这里就是该递归的基准情况了，当基准情况返回到上一层的调用，center的值必然与left是相等的，且right的值必然等于center+1。这个情况不难分析，因为 center = (left + right) / 2,且left与center相等，left不等于right,所以right必然等于center + 1。且该基准情况准只可能对应数组中的起始元素和结束元素，因为在递归调用中为maxLeftSum赋值的时候左边的参数不变，而center会不断减少直到与left相等，而其它方法中执行到了为maxLeftSum赋值的时候已经过了基准条件的筛选，同理为maxRightSum赋值的递归调用也是如此。明白了这一层关系，我们可以从程序的基准情况开始分析，下图的圆形表示从基准情况返回到上一层的时候，maxLeftSum以及maxRightSum的值,如果index对应0和1的值大于0则返回对应的值否则返回0: 26-40行的代码的意思是以中间的虚线左右两边的第一个元素为首元素分别开始往左右找出最大的子序列和，然后将左边与右边的最大的子序列的和相加，再在它和maxLeftSum、maxRightSum三个值中取最大值。当索引仅为0和1的时候这样处理肯定是可以拿到0、1组合的子数组的最大序列和，但如果递归的结果再往上一层，这样的处理是否依旧合适呢？当递归到第二层，上图递归的返回值为下图的maxLeftSum。下图展示了下一层递归的结果:(右边可能的Index有两种情况，一种是仅存在一个元素Index = 2，一种是存在元素Index = 2 和 Index = 3,这里我们为了更好的展示过程取两个元素的情况) 这个时候如果还是按照之前的处理，取三者之间的最大值作为最大子序列和的结果是否合适呢？这里需要分情况讨论，现在我们可以确定的是maxLeftSum一定是左边数组最大的子序列的和，maxRightSum一定是右边数组最大的子序列的和。如果存在最大子序列的和不仅是单独取左边和右边里的元素，而是左右两边都需要取值构成最大子序列的和，那么这个对于整体而言的最大子序列一定是包含虚线左右两侧的元素的，因为一个子序列一定是连续的，这样的话就可以按照之前的方法分别从虚线开始往左右两边求最大子序列的和相加一定可以得到整个数组的最大子序列的和。如果不存在最大的子序列的和同时依赖于左和右两边的元素，我们针对maxLeftSum和maxRightSum取较大值即可得到最大子序列和。综合考虑上面两种情况，这样我们在这三个值中取最大值一定可以得到这个数组块的最大子序列和。这个可以递推到无论数组被分为多少块的情况，在数学的证明里也经常使用到这样的方式去证明一个定理，对于某个较小的情况条件成立，我们将这个较小的情况取为一般情况K，然后再证明K+1的情况成立，那么结论一定是成立的，数学里称为归纳假设，同样在这个情况下证明这个递归算法的正确性使用到了相似的方式。 验证了这个算法的正确性之后，不可缺少的工作是去计算这个算法的时间复杂度。假设我们处理的数组长度为N，仅对maxSubSum3(int[] a,int left,int right)的执行时间进行计算，设其执行时间为T(N)。在这个方法内，15-20行的执行时间为一个常数时间量，设为T(1) = 1；对于26-40行的两个for循环，会遍历$ A_0 到 A_{ N-1 } $的每个元素，在每个循环内部耗费的时间都为常量，因此可设其执行时间为O(N)；接下来就是在23、24上两个递归方法的调用消耗的时间，这两行求解的数组长度大小为N/2，总计消耗的时间为2T(N/2)。忽略常数时间，可以得: \\displaystyle T(N) = T(\\dfrac{N}{2}) + O(N) 为了简化计算，我们可以使用N代替上式的O(N)，那么T(N) = 2T(N/2) + N,且有T(1) = 1,那么 T(2) = 2*2 + 2 = 2*2 = 4,T(4) = 2*4 + 4 = 3*4 = 12,T(8) = 2T(4) + 8 = 2*12 + 8 = 4*8 = 32,T(16) = 2T(8) + 16 = 2*32 + 16 = 5*16 = 80 …… 即若$ N = 2^k $,则有: \\displaystyle T(N) = N * (k+1) = NlogN + N = O(NlogN) 当然这里的计算结果是假设当$ N = 2^k $的情况，当N不是这个值的时候，需要一些更复杂的分析，但大O的结果是不变的。显然该算法的时间复杂度要比第二种方式低，本来以为到这里已经是最快的解决方式了，可是接下来还有一种比第三种方式时间复杂度更低的算法…而且实现起来居然更简单…不得不为思维的力量折服。 Ｏ(≧▽≦)Ｏ 第四种方式1234567891011121314151617181920212223242526272829 public static void main(String[] args)&#123; int[] a = new int[]&#123;11, -21, 5, 11, -42&#125;; System.out.println(maxSubSum4(a)); &#125; /** * 最大子序列求和 第四种写法 * @param a * @return */ private static int maxSubSum4(int[] a)&#123; int maxSum = 0, thisSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; thisSum += a[ i ]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125;else if( thisSum &lt; 0)&#123; thisSum = 0; &#125; &#125; return maxSum; &#125; /* 输出结果: 16*/ 这个算法的时间复杂度可以看出来为O(N),但是粗看会质疑这个算法的正确性，因为这里仅有一个for循环去遍历数组中的值，难道这能就求出最大子序列的和？ (╬￣皿￣)=○ 那我们之前的努力不是徒劳了？别着急，慢慢来看这个算法到底是怎么回事。 分析程序可以得出，当thisSum为负值的时候，就选择抛弃前面的计算结果，选择从第一个非负值开始递增寻找最大子序列和。当在数组中前几个数字为负值的时候，这样的做法明显是正确的，因为负值不可能作为最大子序列和的开始。但是如果这样的一个序列出现在数组的中间的时候呢？我们假设从a[i]到a[j]出现了一个计算序列结果为负数的情况，那么假设可以从p(p为i+1到j之间的一个整数)开始得到一个比当前最大更大的子序列和，由于子序列必定是连续的，且从a[i]到a[p-1]的和是大于0的，那么很明显我们如果从a[i]开始要比从a[p]开始可以得到一个更大的子序列和。然后再做这样一个比较，从i开始和从j+1开始对比，如果存在一个从j+1开始的子序列的和比当前的最大的子序列大的情况，也是由于子序列的连续性，那么显然从j+1开始要比从i开始的值大，因为a[i]到a[j]的和是一个负数。所以如果出现负数的情况，如果后续还存在一个更大的子序列和，那么它的起点必然是在j之后而不可能在j之前。当然如果不存在从i+1开始存在比当前子序列更大的情况，我们继续累加也是不可能得出一个比当前最大子序列和更大的值。所以我们仅考虑存在比当前子序列更大的情况即可。如果存在从i+1开始比当前子序列更大的情况，综前所述，也必然出现在j之后。 看似简单的程序其实蕴含了丰富的思考，掌握了这个求最大和问题的本质。 (=ﾟωﾟ)ﾉ End","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://swcheng.com/categories/JAVA/"},{"name":"DATA_STRACTURE","slug":"JAVA/DATA-STRACTURE","permalink":"http://swcheng.com/categories/JAVA/DATA-STRACTURE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"Comparator && Comparable in Java","slug":"Comparator && Comparable","date":"2018-11-06T08:33:00.000Z","updated":"2019-05-19T09:42:05.859Z","comments":true,"path":"2018/11/06/Comparator && Comparable/","link":"","permalink":"http://swcheng.com/2018/11/06/Comparator && Comparable/","excerpt":"Comparator和Comparable是Java中将对象按照数据成员进行排序的两个接口，最近在读《数据结构与算法分析 Java语言描述》_-Mark Allen Weiss_ ,看到书中的例子使用到了这两个接口，所以就想学习一下Java中这两个接口的使用方式 (｀・ω・´)","text":"Comparator和Comparable是Java中将对象按照数据成员进行排序的两个接口，最近在读《数据结构与算法分析 Java语言描述》_-Mark Allen Weiss_ ,看到书中的例子使用到了这两个接口，所以就想学习一下Java中这两个接口的使用方式 (｀・ω・´) 在Java中Comparable接口定义为:123456package java.lang;import java.util.*;public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 接口中仅定义了一个compareTo()方法，自定义的对象则可以通过实现这个方法并结合Collections.sort()进行排序。比如自定义一个Order类:12345678910111213141516171819202122public class Order implements Comparable&lt;Order&gt;&#123; private int orderNumber; private String orderDes; private LocalDate orderTime; public Order(int orderNumber, String orderDes, LocalDate orderTime) &#123; this.orderNumber = orderNumber; this.orderDes = orderDes; this.orderTime = orderTime; &#125; @Override public int compareTo(Order o) &#123; return this.getOrderNumber() - o.getOrderNumber(); &#125; @Override public String toString() &#123; return this.orderNumber + \" \" + this.orderDes + \" \" + this.orderTime; &#125; // ... 省略getter setter 该Order类中定义了三个字段orderNumber、orderDes、orderTime，依次表示订单号、订单描述、订单时间。compareTo()方法简单的返回订单号的值的相减结果，第一次单元测试用例如下:12345678910111213141516171819 @Test void testComparableSimple() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(71,\"order 71\",LocalDate.of(2015,2,7))); lists.add(new Order(691,\"order 691\",LocalDate.of(2011,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); for (int i = 0; i &lt; lists.size() - 1 ; i++) &#123; System.out.println(\"第\" + i +\"个元素与第\" + (i+1) + \"元素进行比较:\" + lists.get(i).compareTo(lists.get(i+1))); &#125; &#125;/* 输出结果: 第0个元素与第1元素进行比较:-98 第1个元素与第2元素进行比较:150 第2个元素与第3元素进行比较:-620 第3个元素与第4元素进行比较:272*/ 从上面的输出结果可以看出，Order类实现的Comparable接口的作用就是用于与其它Order对象使用compareTo()进行比较并返回一个int值。目前我们还看不出这个方法的作用，但是我们再看下一个单元测试就会明白其的作用了:12345678910111213141516171819202122232425262728293031323334@Testvoid testComparableSecond() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(71,\"order 71\",LocalDate.of(2015,2,7))); lists.add(new Order(691,\"order 691\",LocalDate.of(2011,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); System.out.println(\"未进行排序前的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125; // 调用Collections.sort()进行排序 Collections.sort(lists); System.out.println(\"进行排序之后的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125;&#125;/* 输出结果: 未进行排序前的顺序: 123 order 123 2018-11-06 221 order 221 2012-09-01 71 order 71 2015-02-07 691 order 691 2011-06-21 419 order 419 2009-03-31 进行排序之后的顺序: 71 order 71 2015-02-07 123 order 123 2018-11-06 221 order 221 2012-09-01 419 order 419 2009-03-31 691 order 691 2011-06-21*/ 从输出结果可以看出lists里的数据根据orderNumber进行了升序排序，而这是因为Order实现了Comparable接口的compareTo()方法,我们在该方法中返回相减的结果。当结果为正数，零，或者负数分别表示调用compareTo()的对象大于、等于、小于传递到方法中的参数对象，默认升序排序。如果需要降序排序则返回相反数即可。 至于Comparator接口，如果需要使用其来进行排序则需要编写一个类去实现它的compare()方法，这里我们编写一个先根据订单号再根据订单日期进行排序的实现类SortByOrderNumberAndTime.class:1234567891011121314151617public class SortByOrderNumberAndTime implements Comparator&lt;Order&gt; &#123; /** * 根据订单号进行排序，订单号相同则根据时间进行排序 * @param o1 * @param o2 * @return */ @Override public int compare(Order o1, Order o2) &#123; int numberOrder = o1.getOrderNumber() - o2.getOrderNumber(); int timeOrder = o1.getOrderTime().compareTo(o2.getOrderTime()); if(numberOrder == 0 &amp;&amp; timeOrder != 0) return timeOrder; else return numberOrder; &#125;&#125; 对应的单元测试:1234567891011121314151617181920212223242526272829303132 @Test void testComparator() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(221,\"order 221\",LocalDate.of(2017,2,7))); lists.add(new Order(221,\"order 221\",LocalDate.of(2015,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); System.out.println(\"未进行排序前的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125; Collections.sort(lists,new SortByOrderNumberAndTime()); System.out.println(\"排序之后的顺序\"); for(Order order: lists)&#123; System.out.println(order); &#125; &#125;/*输出结果: 未进行排序前的顺序: 123 order 123 2018-11-06 221 order 221 2012-09-01 221 order 221 2017-02-07 221 order 221 2015-06-21 419 order 419 2009-03-31 排序之后的顺序 123 order 123 2018-11-06 221 order 221 2012-09-01 221 order 221 2015-06-21 221 order 221 2017-02-07 419 order 419 2009-03-31*/ 我们可以看到lists首先根据订单号然后根据时间先后顺序进行了排序，这里也是依据SortByOrderNumberAndTime类中实现的compare()方法进行的排序，并且在compare()里使用到了LocalDate类里的compareTo()方法去比较时间先后顺序，除了LocalDate,Java中许多常用的类也默认提供了对Comparable接口的实现，比如String、Integer、Character、Float、Byte基本数据类型的包装类，具体可以查看官网的Docs。 不论是Comparator接口还是Comparable接口，都是实现排序的一种方式，当然也可以结合一起使用，具体的使用方式还是得取决于最终的需求。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://swcheng.com/categories/JAVA/"},{"name":"DATA_STRACTURE","slug":"JAVA/DATA-STRACTURE","permalink":"http://swcheng.com/categories/JAVA/DATA-STRACTURE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"个人博客开始之旅","slug":"2018-10-19-博客开篇","date":"2018-10-19T14:24:00.000Z","updated":"2019-05-19T10:21:01.824Z","comments":true,"path":"2018/10/19/2018-10-19-博客开篇/","link":"","permalink":"http://swcheng.com/2018/10/19/2018-10-19-博客开篇/","excerpt":"其实一直以来都隐约有想写博客的想法，记得第一篇博客是发表在我的CSDN个人博客上的，内容是如何为Tomcat配置图片访问路径，以及在Eclipse下对Tomcat服务器目录的理解。之所以写那篇博客是因为这个服务器图片的配置困扰自己很长一段时间，好不容易解决了这个大问题，心情十分愉快就想着写篇博客记录下来，以便为存在有与我有一样需求的人提供帮助 ︿(￣︶￣)︿","text":"其实一直以来都隐约有想写博客的想法，记得第一篇博客是发表在我的CSDN个人博客上的，内容是如何为Tomcat配置图片访问路径，以及在Eclipse下对Tomcat服务器目录的理解。之所以写那篇博客是因为这个服务器图片的配置困扰自己很长一段时间，好不容易解决了这个大问题，心情十分愉快就想着写篇博客记录下来，以便为存在有与我有一样需求的人提供帮助 ︿(￣︶￣)︿ 但写那篇博客的时候自己对Markdown语法所知甚少，所以最终写出来的博客巨丑无比，自己最后看了都觉得辣眼睛 ┐(´∀｀)┌,所以之后自己的记录就基本存在于自己的YouDao云笔记上了。直到近来开始学习Web开发的相关知识之后，才觉得书写博客其实是一个很有趣的事情，自己不仅可以在个人博客上记录自己学习的技术知识，也可以记录一些生活上等其他的事情。之前在新浪微博上写过几篇，但总觉得新浪微博更是一个大杂烩一样的平台，所以写了两篇之后自己就想要开始搭建自己的个人博客平台。 当有搭建自己的个人博客的想法之后，刚开始的做法是想要通过搭建一个博客学习Node.js的相关知识的，自己也确实这么去做了，刚接触Nodejs的时候自己还顺带学习了MongoDB的知识，当然只是学习了一点皮毛，然后又去了解在Nodejs使用十分广泛的Express框架，以及与MongoDB交互的API等。但实在是当时需要学习的技术知识太多，时间跨度太大，以及由于准备寻找实习的原因，导致最后有始无终。╮(╯﹏╰）╭ 之后搭建个人博客的事情就一直搁置下来了，由于实习的原因在使用Java开发Web项目，后来自己又想使用Java去搭建一个个人博客，并因此了解到Java有一个非常流行的开源博客项目solo,star的数量达到了5k+,但是自己对于solo的主题却有点不满意，同时这个时候自己又了解到了Hexo Framework,看到hexo的第一眼，马上喜欢上了这个Nodejs博客框架，同时找到了一个自己非常喜欢的主题icarus,于是开始着手学习使用Hexo搭建自己的博客。使用Hexo搭建博客在官网完整的文档和视频说明帮助下，很顺利的完成了一个初步的本地部署并测试基本功能，这时候我就想着如何将这个站点发布提供给其他人访问。想要发布自己的博客站点有很多方式，但对于自己来说主要有下面三个选项: 部署到阿里云服务器 部署到Bandwagon服务器 部署到GithubPages 阿里云服务器对于学生来说特别便宜，大概120RMB/Year,使用阿里云服务器来部署站点的优点是IP地址在国内，访问速度会比较快，缺点是一但自己毕业之后，服务器的价格就不再是之前的价格了，即使是一个比较low的配置也需要不少的费用，下图是我在 2018/10/20 日去阿里云官网查看的轻量级应用服务器最低配置的价格。 (；′⌒`) 低收入人群表示真心付费不起，所以阿里云这个选项就被我给PASS掉了。至于 Bandwagon 云服务器，个人觉得 Bandwagon 是一个非常便宜实用的美国云服务器供应商，Bandwagon 在国内俗称”搬瓦工”,去年我购买的时候官网还没有被墙，现在已经无法访问了 (╯︵╰),哎这个长城防火墙实在是…反正自己是没法理解设计者的思想…个人觉得这个墙的弊远远大于利，不过这也是自己的个人想法，没有办法去改变现状。回到正题，下图是搬瓦工的官网界面: 我们可以看到最便宜的价格是19.9$,但是我们可以从网上找一找优惠码，可以优惠几美刀，毕竟1美刀可是相当6块多RMB呀。对于购买方案的选择，有一个不错的网站自己一直在用，地址是http://banwagong.cn/,感觉还不错，其实最低配以及满足我们普通用户的需求了，但是问题在于购买的VPS是否是选择的CN2直连线路，如果是CN2线路的话大概延迟会在 150~200ms 之间，个人觉得这个延迟时间是可以接受的。如果再为VPS配置Google的BBR拥塞控制的话，还可以降低一部分延迟，虽然降低的延迟不是很多，但毕竟实在是距离太远，能够做到降低一部分延迟已经很不错了。 自己平时使用 Bangwagong 主要是用于配置SSR服务，在自己摸不着头脑的时候用来Google寻找答案的，或者去查看一些官方站点的Doc，也偶尔看看Youtube视频啦 ٩(๑❛ᴗ❛๑)۶ 。所以这时候刚好碰上了部署站点的需求，所以就想这不是一举两得吗?不仅可以用来满足自己的翻墙需求还可以用来发布自己的博客，于是自己就开始为Hexo配置环境，目标主机是Cent OS7,自己也是倒腾一段时间才终于将所有需要配置的东西都配置好。但是当我在80端口运行自己的nginx服务之后，在自己的主机上居然访问不到nginx的页面？开始自己以为是某个地方配置的不对，后来想到可能是墙的锅，于是打开代理，打开代理之后顺利访问到了nginx默认页面，哎…这时候我的心情是复杂的…所有努力付诸东流 既然抵挡不过墙的力量，只能另想办法了，那么只剩下最后一个办法了，使用GitHubPages提供的云空间来发布自己的博客了。对于GithubPages这里就不做过多说明了，使用最多的方式是GithubPages和 Jekyll 来部署自己的个人站点，Jekyll的主题十分丰富，如果有兴趣可以去了解一下。我选择的是 Git本地客户端 + Node.js + Hexo Framework + Icarus + GithubPages + Atom 的方式去编写发布自己的个人博客。em…对于一个新人来说搭建这样一个完整的环境还是不太容易的…因为有太多没有接触的东西，但幸运的是Hexo的官网的文档十分简洁详细，并且之前自己使用过一点Nodejs,所以本地部署测试的过程还算比较顺利。 接下来就是如何发布自己的站点了，使用Hexo部署的deploy命令部署十分方便，但是这个命令的缺点是会将之前repository里的内容全部都干掉重新生成新的静态文件，这样的会导致自己在repository的CNAME和README文件都会被删除，这是自己没法忍受的缺点，所以只能放弃这个命令，转而自己使用Git的版本控制去手动更新新的文件。但是之前自己写的代码要么是通过IDE里自带的VCS要么是使用Github Desktop同步到Github上，感觉图形界面虽然操作方便但是让我对Git的工作方式一点都不了解，还是停留在无脑commit publish状态，想想自己使用了这么长时间的版本控制只会这两个基本的命令实在是惭愧呀。于是下定决心好好到Git的官网去学习关于版本控制的知识，Git官网有一本可以免费下载的Git Pro，提供多国语言翻译支持，自己就Download到kindle上平时上下班在公交车上阅读，这本书的详细叙述了版本控制的发展历史以及对比了Git与其它版本控制的区别，以及Git的所有使用情景，是一本十分优秀的书籍，很值得推荐一看。在将这本书啃完了前几章之后，就可以很轻松的使用Git command去管理Github的远程仓库了。 在我的cheng-github.github.io仓库下，我建立了两个分支，master和hexo。使用master分支存放生成的如html、css、images、js等静态页面文件,使用hexo分支存放本地测试的hexo文件，用作备份的需要。如果需要将原来的Gitpages的默认访问域名修改为个人域名可以进行相关配置，具体配置可以自行Google或者Baidu。 至此博客部署发布算是完成了，ヾ(๑╹◡╹)ﾉ”。希望自己不要忘记写博客的初心，也不要忘记当初决定学习计算机的初心，故而使用封面的图片用于提醒自己。em…最想对自己说… Follow your own voice,尽情去追逐自己想要的一切吧，即使跌倒也不要灰心，别让你眼底的光芒黯淡，that’s really alive.","categories":[{"name":"START","slug":"START","permalink":"http://swcheng.com/categories/START/"},{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]}]}
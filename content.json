{"meta":{"title":"Cheng","subtitle":null,"description":"This is my personal blog using to record and share the technolegy knowlege and feeling of life.","author":"Chengshiwei","url":"http://swcheng.com"},"pages":[{"title":"About","date":"2018-10-21T16:50:18.266Z","updated":"2018-10-21T16:50:18.266Z","comments":true,"path":"about/index.html","permalink":"http://swcheng.com/about/index.html","excerpt":"","text":"My Creation And Participation: 地点 时间 名称 描述 URL 学校 2017-03 ~ 2018-03 ShareBook 刚开始做这个项目的时候，自己连SQL都还没学过，凭着自己的热情和一点Java基础就开始了，在十一月的时候已经完成大部分内容，后续有一些轻微的修补和添加 https://github.com/cheng-github/ShareBooks 学校 2018-12 ~ 2018-01 Sniffer TCP/IP协议课程设计，一个网络嗅探器，为其添加了写入文件功能 https://github.com/cheng-github/Sniffer 学校 2018-05 ~ 2018-10 Hexo博客 Start to express! http://swcheng.com \"Be optimistic,everything will be good\" Sees like a child Give like a saint Feel like an angel Never mind the broken wings And speak like a picture Cry like the rain Shine like the star As long as the fire remains -STEFANIE «Someone»"},{"title":"Tags","date":"2018-09-19T13:26:55.089Z","updated":"2018-09-19T13:26:55.089Z","comments":true,"path":"tags/index.html","permalink":"http://swcheng.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-09-19T13:26:55.088Z","updated":"2018-09-19T13:26:55.088Z","comments":true,"path":"categories/index.html","permalink":"http://swcheng.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"抓取喜爱123音频文件","slug":"抓取喜爱123听故事音频文件","date":"2018-11-24T12:25:00.000Z","updated":"2018-11-25T06:24:57.836Z","comments":true,"path":"2018/11/24/抓取喜爱123听故事音频文件/","link":"","permalink":"http://swcheng.com/2018/11/24/抓取喜爱123听故事音频文件/","excerpt":"滴…你的表弟已上线，问你是否可以帮他把英语听力下载到他的MP3。(；′⌒`)…开始我以为他是不会如何将文件放在MP3的磁盘里面，就对他说将文件下载后放到移动磁盘就OK。然后他又说他老爸找不到下载地址，额….我心想下载地址你找不到我也没办法帮他去远程找下载地址呀…接着表弟就发了个微信分享的链接给我…但当时我不在宿舍，就说回去帮他看看。","text":"滴…你的表弟已上线，问你是否可以帮他把英语听力下载到他的MP3。(；′⌒`)…开始我以为他是不会如何将文件放在MP3的磁盘里面，就对他说将文件下载后放到移动磁盘就OK。然后他又说他老爸找不到下载地址，额….我心想下载地址你找不到我也没办法帮他去远程找下载地址呀…接着表弟就发了个微信分享的链接给我…但当时我不在宿舍，就说回去帮他看看。 回到宿舍已经是八点半，用电脑登录微信，打开表弟给的微信分享，其实就是使用微信的内置浏览器打开了一个地址。复制了链接地址改为使用Chrome打开，看到了下面的在线听听力的界面。 接下来把这个界面点了点，并没有发现听力的下载地址，看来是有意不提供下载地址，于是打开了调试模式查看网页对应的源码，想看看是否能在html界面中找到听力文件的地址，但是定位到对应的按钮点击的html代码，只看到了一个ul列表，里面的li标签只定义了一个class属性。看来音频地址是不会直接保存在html页面中的，(PS: 如果直接保存在html也太容易被获取到了吧) 于是接着查看它的源码。在chorme调试模式下定位到source tab页面，查看当前页面下的所有文件，显然我们的答案不可能存在css、img文件夹里，过滤掉css、img文件夹里的内容，仅关注js文件，下面两个文件出现在视野里: 那明显第一个是jquery在生产环境的名称，第二个文件叫smusic.min.js，里都有些什么内容呢?不妨打开看个究竟。这个js文件最外层是用一个 !function(l) {}(window); 包裹了一些方法的定义，一些变量的声明，但其中核心内容是设计者在其中定义了一个p对象，在js中对象的定义方式与函数声明的语法一样，区别定义一个函数还是一个对象取决于设计者使用它们的方式，如果定义的是一个对象，一般后续会使用 new xxx(…); 形式的语法去创建一个对象，而如果是作为方法调用则直接在js代码中使用 xxx(…); 形式的语法去执行调用。为什么说这个p是核心对象呢？原因是在对象p的prototype属性中定义了大量与播放音频文件相关的方法，这些方法包括 config、createListDom、setBuffer、resetPlayer、setVolume、initPlay、play、pause、getRandomIndex、playByMode、action、init ，顾名思义，init()方法中会执行一些初始化对象需要调用的方法和表达式，action()方法的内容是为不同的按钮添加点击事件，playByMode、play、pause、setVolume、resetPlayer则是与播放mp3音频操作相关的方法，config则是进行一些相关的配置…如果对这些方法具体的内容有兴趣，可以去仔细研究一下每一步它的执行，但在这里就不做过于详细的阐述了。 注意: js中没有java中的继承，它实现不同对象间共享变量、方法的方式是使用一个共享的原型对象，在这个原型对象中定义的方法和变量可以在任何一个通过其构造函数创建的对象中直接使用 !function(l) {}(window); 的作用与 (funcion(){})(); 一样，都是定义一个匿名函数接着进行对自身的调用，这种方式是在前面加上了!符号提示编译器这不是一个函数声明，而是一个表达式，从而实现与后者相同的效果。其它的运算符如 +、- 等也可以实现同样的作用，如果有兴趣可以研究一下它们之间的区别。 粗略的研究了一下 smusic.min.js 的内容，下一步就可以通过断点来追踪具体的执行过程了，我选择的是将这个断点打在了p对象的构造函数里面调用init()方法的地方，结果如下图所示，下图需要关注的地方被红圈标注出来了。 在对象p的构造函数中很容易可以注意到,为config进行了赋值，接着调用了原型对象中的init()方法。在这个构造函数中，很容易注意到musicList变量，可以将这个变量添加到watch里面追踪值的变化，然后可以看到其具体的内容，明显这里的musicList是一个数组，数组里的内容如下图所示: 显然这是一个json数组，里面的json对象包括了四个键值对，title、cover、singer、src，红色方框标注的内容是对应mp3文件的地址，这就是我们要寻找的东西啦。开始我的做法是在调试的时候直接将这个json数组里的内容copy到文件里，但是这样做会有一个问题，这个问题会导致我们拿不到正确的文件地址，原因是chrome在调试模式查看值的时候，如果一条记录的值过于长，不会显示所有的内容，而是会将结尾字符串的部分内容替换为…，但是我一开始并没有注意到这个问题，而是直接拿着这个url调用java的http api去下载，导致出现404错误，提示找不到对应的文件…刚开始我还以为这个站点做了安全措施…但是其实并没有…只是自己拿的方式有问题，正确的方式应该是使用JSON.stringify()将这个数组转为字符串，然后再存入到文件里。(当然也有将json字符串转换为对象的方法，需要使用JSON.parse()方法，注意参数需要使用单引号，因为json字符串的内容包含双引号，如果再使用双引号去包裹参数就会提示语法错误) 到了这里其实已经完成的差不多了，下面都是Java需要解决的问题了，由于存在172条记录，如果手动去提取地址再下载未免太麻烦，所以我的做法是使用Java的io流读取这个文件里的内容到一个StringBuffer对象中，当然也可以使用StringBuilder，这两个的主要区别是StringBuffer是线程安全，StringBuilder不是线程安全的。由于我使用的是单线程下载，所以无论是使用StringBuffer还是StringBuilder其实都一样。将文件的内容读取到StringBuffer对象中之后，就可以愉快的进行我们想要的操作了。将所有的地址提取出来可以使用Java里的正则表达式，其核心的两个对象是Pattern和Matcher。匹配方式有三种，分别是matches、lookingAt、find，这三种的区别是matches是用于匹配整个字符串，就是说需要pattern和输入的字符串完全相等的时候才会返回true。lookingAt方法会匹配输入字符串的开头，仅当输入的字符串的开头部分满足匹配模式的时候返回true。find方法会扫描整个输入字符串，并且是逐个寻找满足条件的匹配模式，直到找不到匹配的内容为止。在这个需求里，匹配需要的地址就很容易啦，字符串内容的开头一定是http://ting.xiai123.com/mp3/，结尾一定是.mp3，这样去编写匹配模式就Ok。将匹配到的所有的url存入一个字符串数组中，接下来就是逐个去下载的问题啦，这里就不一一介绍了，自己踩的一个坑是将地址进行URLEncoder的时候选择了全部的地址，其实只需要将结尾部分进行重新编码就ok了，但是使用Java调用URLEncoder.encode()方法还存在着一个问题就是空白符会被替换成+，正确的替换结果应该是%20，无奈自己只能再调用一个replaceAll方法去替换。 如果对这些代码有兴趣的话可以在这里下载，https://github.com/cheng-github/DataStructure_Java/tree/master/src/test/java/download。如果这个站点的源码有更多兴趣可以打一些断点，在Call Stack跟踪方法执行流程，以及Watch关键变量的值。 这个网站没有作任何的保护措施，但是我还是一直弄到晚上一点才搞定，同时自己也发现抓取一个站点的数据其实是特别有意思的，听说Python对此有更强大的支持，赶紧去了解一下。(*´ﾟ∀ﾟ｀)ﾉ End","categories":[{"name":"DATA SCRAPING","slug":"DATA-SCRAPING","permalink":"http://swcheng.com/categories/DATA-SCRAPING/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"求最大子序列和的四种实现方式","slug":"2018-11-19_最大子序列求和","date":"2018-11-18T08:20:00.000Z","updated":"2018-11-19T08:45:29.194Z","comments":true,"path":"2018/11/18/2018-11-19_最大子序列求和/","link":"","permalink":"http://swcheng.com/2018/11/18/2018-11-19_最大子序列求和/","excerpt":"在总结求最大子序列和的四种实现方式之前想谈谈为什么自己想要重新学习数据结构。之前在大二下学期的时候已经学过了数据结构这个课程，依稀记得老师一直提醒我们数据结构是计算机的核心课程，并且对于考研或者是找工作面试都是很重要的，特地提醒我们要重视这门课程，希望我们好好学习数据结构。当时自己在上数据结构这个课程之前已经使用过基本的数据结构-链表完成了大一下学期的一个C语言课程设计，记得那是自己使用C语言写的一个程序，虽然仅有一百多行，显示界面也只是一个小黑框，但完成的时候特别激动，因为那是自己真正意义上动手写的第一个完整程序。本来还想找到原来的代码运行一下，但发现自己前一段时间为了清理笔记本空间已经将自己之前写的关于C的代码都删除了 ╮(╯﹏╰）╭","text":"在总结求最大子序列和的四种实现方式之前想谈谈为什么自己想要重新学习数据结构。之前在大二下学期的时候已经学过了数据结构这个课程，依稀记得老师一直提醒我们数据结构是计算机的核心课程，并且对于考研或者是找工作面试都是很重要的，特地提醒我们要重视这门课程，希望我们好好学习数据结构。当时自己在上数据结构这个课程之前已经使用过基本的数据结构-链表完成了大一下学期的一个C语言课程设计，记得那是自己使用C语言写的一个程序，虽然仅有一百多行，显示界面也只是一个小黑框，但完成的时候特别激动，因为那是自己真正意义上动手写的第一个完整程序。本来还想找到原来的代码运行一下，但发现自己前一段时间为了清理笔记本空间已经将自己之前写的关于C的代码都删除了 ╮(╯﹏╰）╭ em….一个订餐管理程序，有显示当前订单列表、添加订餐信息、删除订餐信息、修改订餐信息、根据价格为订单排序、将已有订餐信息写入文件等几个简单的小功能，尤其是添加写入到文件这个模块的时候，自己遇到不知道如何解决的一个地方一直没法正常写入到文件，在CSDN上提问然后得到了一位前辈的指教才顺利的完成的这个功能，thanks ( • ̀ω•́ )✧ 。这个程序当时给老师展示之后最后拿了93分的成绩，自己对于成绩倒不是特别在意，但这也是老师对自己的一种认可吧，更让自己开心的是探索的过程。那是自己第一次接触数据结构，被链表折磨的死去活来，去图书馆借书学习链表，一本看不懂就再借另外一本，读了好几本不同书籍关于链表的内容才开始慢慢理解它，至今还能回忆起当初冥思苦想的那几天。(￣∇￣) 不知不觉又扯了这么远…回到正题，一个学期学习数据结构的时间肯定是不够的，更何况自己当时还并没有花特别多的时间去钻研数据结构，对于每种数据结构都仅仅是简单按照书上的例子实现了一遍，到了现在该忘都忘的差不多了…(╯︵╰) 但真正让我决定重新学习数据结构的原因不是自己想要温习知识，之前面试阿里的时候，面试结束的面试官问我有什么问题想要问他的，我觉得自己面试过程中回答的不好，所以就问面试官对于自己的学习有什么建议没有。面试官就说，培养一个掌握基本开发技能的普通程序员很容易，但数据结构是十分重要的，理解技术的原理也是十分重要的，还讲violate的原理给我听。加上之前在公司的季度技术交流会上，看见某位大佬秀了一波关于数据库方面的数据结构的知识，当时自己真是热血沸腾的感觉，并且那一刻真正的意识到是时候该找时间好好的学习数据结构了，于是才选择了《数据结构与算法分析 Java语言描述》-Mark Allen Weiss这本书，并计划一边学习这本书一边写博客记录学习过的内容。最后说一下自己的粗见吧，数据结构可能暂时在开发小型程序的作用还不是特别明显，搭建好开发环境之后，只要对某种语言比较熟练就可以做到业务上的实现，但是如果涉及到大型的应用的构建，当应用吞吐量很大的时候，一个小的细节对于应用整体的性能的作用就会比较明显了，这时候我们不仅需要了解使用到的技术的原理，而且需要更有技巧的编程，用更少的执行时间去完成相同的任务，相反而不是去粗暴的使用蛮力算法实现需求。所以从长远的角度来看，熟练掌握数据结构是十分必要的。 最大子序列和，就是指在一个元素类型为整型的数组中，求其中连续的一个序列和的最大值，这个序列的开始下标可以是数组中的任意位置。如果我们按照列举所有可能情况的思考方式编写代码: 第一种方式 123456789101112131415161718192021222324252627282930public static void main(String[] args)&#123; int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; System.out.println(maxSubSum1(a));&#125;/** * 最大子序列和,最简单直接的求最大子序和 * @return */private static int maxSubSum1(int[] a)&#123; int maxSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; for (int j = i; j &lt; a.length; j++) &#123; int thisSum = 0; for (int k = i; k &lt;= j; k++) &#123; thisSum += a[k]; &#125; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; &#125; &#125; return maxSum;&#125;/* 输出结果: 50*/ 很明显，这里的最大子序列和为前五个元素的和。下面我们分析一下该算法的时间复杂度。假设我们输入的数组的长度为N，忽略声明、调用方法、返回值的开销，仅关注嵌套的for循环所占用的时间，那么所耗费的时间为: $ \\displaystyle \\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^j1 $ 对该表达式从里到外求和: \\displaystyle \\sum_{ k=i }^j1=j-i+1 继续从里往外求和: \\displaystyle \\sum_{ j=i }^{ N-1 }( j-i+1 )=\\dfrac{( N-i+1 )( N-i )}{2} 所以有: $ \\displaystyle \\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^j1 $ = $ \\displaystyle \\sum_{ i=0 }^{ N-1 }{\\dfrac{( N-i+1 )( N-i )}{2}} $ = $ \\displaystyle \\sum_{ i=1 }^{ N }{\\dfrac{( N-i+2 )( N-i+1 )}{2}} $ = $ \\displaystyle \\sum_{ i=1 }^{ N }{ ( \\dfrac{i^2}{2} - \\dfrac{ 3i + 2iN }{ 2 } + \\dfrac{N^2 + 3N + 2 }{ 2 } ) } $ = $ \\displaystyle \\dfrac12 \\sum_{ i=1 }^{ N }{ i^2 } - (\\dfrac{ 3+2N }{ 2 })\\sum_{ i=1 }^{ N }{ i } + (\\dfrac{N^2 + 3N + 2}{ 2 })\\sum_{ i=1 }^{ N }{ 1 } $ = $ \\displaystyle \\dfrac12 \\dfrac{ N(N+1)(N+2) }{6} - (\\dfrac{ 3+2N }{ 2 })\\dfrac{ N(N+1) }{2} + \\dfrac{N^2 + 3N + 2}{ 2 }N $ = $ \\displaystyle \\dfrac{ N(N+1)(N+2) }{ 6 } $ 经计算可知该算法的时间复杂度为$ O(N^3) $，其实我们没有必要通过三层的for循环穷举所有的子序列的和，上面的第三层的for循环的计算明显存在冗余，仅仅两个for循环就可以满足求和需求: 第二种方式 12345678910111213141516171819202122public static void main(String[] args)&#123; int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; System.out.println(maxSubSum2(a));&#125;private static int maxSubSum2(int[] a)&#123; int maxSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; int thisSum = 0; for (int j = i; j &lt; a.length; j++) &#123; thisSum += a[j]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; &#125; &#125; return maxSum;&#125;/* 输出结果: 50*/ 仅关注嵌套的for循环所占用的时间，那么所耗费的时间最多为: $ \\displaystyle \\sum_{ i=0 }^{ N-1 } \\sum_{ j=i }^{ N-1 }3 $ 对该表达式从里到外进行求和计算: $ \\displaystyle \\sum_{ i=0 }^{ N-1 } \\sum_{ j=i }^{ N-1 }3 $ = $ \\displaystyle 3\\sum_{ i=0 }^{ N-1 }(N-i) $ = $ \\displaystyle 3\\sum_{ i=1 }^{ N }( N-i+1 ) $ = $ \\displaystyle \\dfrac{ 3N(N+1) }{ 2 } $ 计算知第二种方法的时间复杂度为$ O(N^2) $。第二种方式避免了单独计算每个子序列结果的值，在第一种方式里，当第二层循环的j取最大值的时候，最里面的循环累加的结果包含了j取其它值的情况。而第二种方式正好避免这种冗余的计算，将每次累加的结果与当前最大的结果对比，从而降低了时间复杂度。以为这就是最优秀的方法了吗？然而编程思想的威力远没有这么简单，第三种方式采用了在算法设计中普遍采用的一种方式-“分而治之”: 第三种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args)&#123;// int[] a = new int[]&#123; 19, 2, -20, 14, 35, -3, -21, 10, -22 &#125;; int[] a = new int[]&#123;-11, -21, -5, -11, -42&#125;; System.out.println(maxSubSum3(a, 0, a.length - 1));&#125;/** * 最大子序列和 第三种方式 * @param a * @return */private static int maxSubSum3(int[] a,int left,int right)&#123; // 对于递归方法总会有一个基准情况，这里的left与right相等的时候就是我们这里例子的基准 if( left == right )&#123; if( a[ left ] &gt; 0) return a[ left ]; else return 0; &#125; int center = (left + right) / 2; int maxLeftSum = maxSubSum3(a, left, center); int maxRightSum = maxSubSum3(a, center + 1, right); int maxLeftBorderSum = 0, leftBorderSum = 0; for (int i = center; i &gt;= left; i--) &#123; leftBorderSum += a[ i ]; if( leftBorderSum &gt; maxLeftBorderSum)&#123; maxLeftBorderSum = leftBorderSum; &#125; &#125; int maxRightBorderSum = 0, rightBorderSum = 0; for (int i = center + 1; i &lt;= right; i++) &#123; rightBorderSum += a[ i ]; if(rightBorderSum &gt; maxRightBorderSum)&#123; maxRightBorderSum = rightBorderSum; &#125; &#125; return max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);&#125;private static int max3(int a,int b,int c)&#123; if (b &gt; a || c &gt; a)&#123; if(b &gt; c) return b; else return c; &#125; else &#123; return a; &#125;&#125; 显然第三种方式的代码要比前两种复杂，但是复杂不是出发点，我们的目的是减少时间复杂度。在第三种方式中，核心方法是int maxSubSum3(int[] a,int left,int right)，递归方法往往都存在着一个基准情况，不然递归就会无限循环调用下去，程序也毫无意义了。在这里15-20行是这个递归方法的基准情况，方法中的23、24行中进行了对自身的调用。接下来分析这个代码是如何执行的，为了更清楚该代码的执行过程，我调试程序的时候特意注释掉了main方法之前在第一种方式和第二种方式使用到的参数，使用数量较少的参数去还原该算法整个过程。方法中有三个参数，int[] a、int left、int right，第一次传递到该方法中的实参是数组a的起始下标和结束下标，显然第一次调用该方法是不满足基准情况的，在不满足基准情况下继续往下执行，计算left和right的平均值，如果不能整除则取去掉小数位的数值。然后分别将center作为right的实参传递到maxSubSum3()为maxLeftSum赋值，center+1作为left的实参传递到maxSubSum3()为maxRightSum赋值。顾名思义，maxLeftSum和maxRightSum其实就是将数组分为左右两块之后左右两个数组的最大子序列和的值。但是我们怎么知道这两个变量的值是左右两个数组的最大子序列和的值呢？仅从外层去理解这个程序是无法得出这个结论的，我们不妨追溯到该程序的基准情况，left=right。 当left与right相等的时候，程序会判断数组对应left的索引下标的值是否大于0，如果大于0，则返回对应值，小于0则返回0。显然这里就是该递归的基准情况了，当基准情况返回到上一层的调用，center的值必然与left是相等的，且right的值必然等于center+1。这个情况不难分析，因为 center = (left + right) / 2,且left与center相等，left不等于right,所以right必然等于center + 1。且该基准情况准只可能对应数组中的起始元素和结束元素，因为在递归调用中为maxLeftSum赋值的时候左边的参数不变，而center会不断减少直到与left相等，而其它方法中执行到了为maxLeftSum赋值的时候已经过了基准条件的筛选，同理为maxRightSum赋值的递归调用也是如此。明白了这一层关系，我们可以从程序的基准情况开始分析，下图的圆形表示从基准情况返回到上一层的时候，maxLeftSum以及maxRightSum的值,如果index对应0和1的值大于0则返回对应的值否则返回0: 26-40行的代码的意思是以中间的虚线左右两边的第一个元素为首元素分别开始往左右找出最大的子序列和，然后将左边与右边的最大的子序列的和相加，再在它和maxLeftSum、maxRightSum三个值中取最大值。当索引仅为0和1的时候这样处理肯定是可以拿到0、1组合的子数组的最大序列和，但如果递归的结果再往上一层，这样的处理是否依旧合适呢？当递归到第二层，上图递归的返回值为下图的maxLeftSum。下图展示了下一层递归的结果:(右边可能的Index有两种情况，一种是仅存在一个元素Index = 2，一种是存在元素Index = 2 和 Index = 3,这里我们为了更好的展示过程取两个元素的情况) 这个时候如果还是按照之前的处理，取三者之间的最大值作为最大子序列和的结果是否合适呢？这里需要分情况讨论，现在我们可以确定的是maxLeftSum一定是左边数组最大的子序列的和，maxRightSum一定是右边数组最大的子序列的和。如果存在最大子序列的和不仅是单独取左边和右边里的元素，而是左右两边都需要取值构成最大子序列的和，那么这个对于整体而言的最大子序列一定是包含虚线左右两侧的元素的，因为一个子序列一定是连续的，这样的话就可以按照之前的方法分别从虚线开始往左右两边求最大子序列的和相加一定可以得到整个数组的最大子序列的和。如果不存在最大的子序列的和同时依赖于左和右两边的元素，我们针对maxLeftSum和maxRightSum取较大值即可得到最大子序列和。综合考虑上面两种情况，这样我们在这三个值中取最大值一定可以得到这个数组块的最大子序列和。这个可以递推到无论数组被分为多少块的情况，在数学的证明里也经常使用到这样的方式去证明一个定理，对于某个较小的情况条件成立，我们将这个较小的情况取为一般情况K，然后再证明K+1的情况成立，那么结论一定是成立的，数学里称为归纳假设，同样在这个情况下证明这个递归算法的正确性使用到了相似的方式。 验证了这个算法的正确性之后，不可缺少的工作是去计算这个算法的时间复杂度。假设我们处理的数组长度为N，仅对maxSubSum3(int[] a,int left,int right)的执行时间进行计算，设其执行时间为T(N)。在这个方法内，15-20行的执行时间为一个常数时间量，设为T(1) = 1；对于26-40行的两个for循环，会遍历$ A_0 到 A_{ N-1 } $的每个元素，在每个循环内部耗费的时间都为常量，因此可设其执行时间为O(N)；接下来就是在23、24上两个递归方法的调用消耗的时间，这两行求解的数组长度大小为N/2，总计消耗的时间为2T(N/2)。忽略常数时间，可以得: \\displaystyle T(N) = T(\\dfrac{N}{2}) + O(N) 为了简化计算，我们可以使用N代替上式的O(N)，那么T(N) = 2T(N/2) + N,且有T(1) = 1,那么 T(2) = 2*2 + 2 = 2*2 = 4,T(4) = 2*4 + 4 = 3*4 = 12,T(8) = 2T(4) + 8 = 2*12 + 8 = 4*8 = 32,T(16) = 2T(8) + 16 = 2*32 + 16 = 5*16 = 80 …… 即若$ N = 2^k $,则有: \\displaystyle T(N) = N * (k+1) = NlogN + N = O(NlogN) 当然这里的计算结果是假设当$ N = 2^k $的情况，当N不是这个值的时候，需要一些更复杂的分析，但大O的结果是不变的。显然该算法的时间复杂度要比第二种方式低，本来以为到这里已经是最快的解决方式了，可是接下来还有一种比第三种方式时间复杂度更低的算法…而且实现起来居然更简单…不得不为思维的力量折服。 Ｏ(≧▽≦)Ｏ 第四种方式1234567891011121314151617181920212223242526272829 public static void main(String[] args)&#123; int[] a = new int[]&#123;11, -21, 5, 11, -42&#125;; System.out.println(maxSubSum4(a)); &#125; /** * 最大子序列求和 第四种写法 * @param a * @return */ private static int maxSubSum4(int[] a)&#123; int maxSum = 0, thisSum = 0; for (int i = 0; i &lt; a.length; i++) &#123; thisSum += a[ i ]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125;else if( thisSum &lt; 0)&#123; thisSum = 0; &#125; &#125; return maxSum; &#125; /* 输出结果: 16*/ 这个算法的时间复杂度可以看出来为O(N),但是粗看会质疑这个算法的正确性，因为这里仅有一个for循环去遍历数组中的值，难道这能就求出最大子序列的和？ (╬￣皿￣)=○ 那我们之前的努力不是徒劳了？别着急，慢慢来看这个算法到底是怎么回事。 分析程序可以得出，当thisSum为负值的时候，就选择抛弃前面的计算结果，选择从第一个非负值开始递增寻找最大子序列和。当在数组中前几个数字为负值的时候，这样的做法明显是正确的，因为负值不可能作为最大子序列和的开始。但是如果这样的一个序列出现在数组的中间的时候呢？我们假设从a[i]到a[j]出现了一个计算序列结果为负数的情况，那么假设可以从p(p为i+1到j之间的一个整数)开始得到一个比当前最大更大的子序列和，由于子序列必定是连续的，且从a[i]到a[p-1]的和是大于0的，那么很明显我们如果从a[i]开始要比从a[p]开始可以得到一个更大的子序列和。然后再做这样一个比较，从i开始和从j+1开始对比，如果存在一个从j+1开始的子序列的和比当前的最大的子序列大的情况，也是由于子序列的连续性，那么显然从j+1开始要比从i开始的值大，因为a[i]到a[j]的和是一个负数。所以如果出现负数的情况，如果后续还存在一个更大的子序列和，那么它的起点必然是在j之后而不可能在j之前。当然如果不存在从i+1开始存在比当前子序列更大的情况，我们继续累加也是不可能得出一个比当前最大子序列和更大的值。所以我们仅考虑存在比当前子序列更大的情况即可。如果存在从i+1开始比当前子序列更大的情况，综前所述，也必然出现在j之后。 看似简单的程序其实蕴含了丰富的思考，掌握了这个求最大和问题的本质。 (=ﾟωﾟ)ﾉ End","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://swcheng.com/categories/JAVA/"},{"name":"DATA_STRACTURE","slug":"JAVA/DATA-STRACTURE","permalink":"http://swcheng.com/categories/JAVA/DATA-STRACTURE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"Comparator && Comparable in Java","slug":"Comparator && Comparable","date":"2018-11-06T08:33:00.000Z","updated":"2018-11-08T14:19:22.565Z","comments":true,"path":"2018/11/06/Comparator && Comparable/","link":"","permalink":"http://swcheng.com/2018/11/06/Comparator && Comparable/","excerpt":"Comparator和Comparable是Java中将对象按照数据成员进行排序的两个接口，最近在读《数据结构与算法分析 Java语言描述》_-Mark Allen Weiss_ ,看到书中的例子使用到了这两个接口，所以就想学习一下Java中这两个接口的使用方式 (｀・ω・´)","text":"Comparator和Comparable是Java中将对象按照数据成员进行排序的两个接口，最近在读《数据结构与算法分析 Java语言描述》_-Mark Allen Weiss_ ,看到书中的例子使用到了这两个接口，所以就想学习一下Java中这两个接口的使用方式 (｀・ω・´) 在Java中Comparable接口定义为:123456package java.lang;import java.util.*;public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 接口中仅定义了一个compareTo()方法，自定义的对象则可以通过实现这个方法并结合Collections.sort()进行排序。比如自定义一个Order类:12345678910111213141516171819202122public class Order implements Comparable&lt;Order&gt;&#123; private int orderNumber; private String orderDes; private LocalDate orderTime; public Order(int orderNumber, String orderDes, LocalDate orderTime) &#123; this.orderNumber = orderNumber; this.orderDes = orderDes; this.orderTime = orderTime; &#125; @Override public int compareTo(Order o) &#123; return this.getOrderNumber() - o.getOrderNumber(); &#125; @Override public String toString() &#123; return this.orderNumber + \" \" + this.orderDes + \" \" + this.orderTime; &#125; // ... 省略getter setter 该Order类中定义了三个字段orderNumber、orderDes、orderTime，依次表示订单号、订单描述、订单时间。compareTo()方法简单的返回订单号的值的相减结果，第一次单元测试用例如下:12345678910111213141516171819 @Test void testComparableSimple() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(71,\"order 71\",LocalDate.of(2015,2,7))); lists.add(new Order(691,\"order 691\",LocalDate.of(2011,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); for (int i = 0; i &lt; lists.size() - 1 ; i++) &#123; System.out.println(\"第\" + i +\"个元素与第\" + (i+1) + \"元素进行比较:\" + lists.get(i).compareTo(lists.get(i+1))); &#125; &#125;/* 输出结果: 第0个元素与第1元素进行比较:-98 第1个元素与第2元素进行比较:150 第2个元素与第3元素进行比较:-620 第3个元素与第4元素进行比较:272*/ 从上面的输出结果可以看出，Order类实现的Comparable接口的作用就是用于与其它Order对象使用compareTo()进行比较并返回一个int值。目前我们还看不出这个方法的作用，但是我们再看下一个单元测试就会明白其的作用了:12345678910111213141516171819202122232425262728293031323334@Testvoid testComparableSecond() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(71,\"order 71\",LocalDate.of(2015,2,7))); lists.add(new Order(691,\"order 691\",LocalDate.of(2011,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); System.out.println(\"未进行排序前的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125; // 调用Collections.sort()进行排序 Collections.sort(lists); System.out.println(\"进行排序之后的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125;&#125;/* 输出结果: 未进行排序前的顺序: 123 order 123 2018-11-06 221 order 221 2012-09-01 71 order 71 2015-02-07 691 order 691 2011-06-21 419 order 419 2009-03-31 进行排序之后的顺序: 71 order 71 2015-02-07 123 order 123 2018-11-06 221 order 221 2012-09-01 419 order 419 2009-03-31 691 order 691 2011-06-21*/ 从输出结果可以看出lists里的数据根据orderNumber进行了升序排序，而这是因为Order实现了Comparable接口的compareTo()方法,我们在该方法中返回相减的结果。当结果为正数，零，或者负数分别表示调用compareTo()的对象大于、等于、小于传递到方法中的参数对象，默认升序排序。如果需要降序排序则返回相反数即可。 至于Comparator接口，如果需要使用其来进行排序则需要编写一个类去实现它的compare()方法，这里我们编写一个先根据订单号再根据订单日期进行排序的实现类SortByOrderNumberAndTime.class:1234567891011121314151617public class SortByOrderNumberAndTime implements Comparator&lt;Order&gt; &#123; /** * 根据订单号进行排序，订单号相同则根据时间进行排序 * @param o1 * @param o2 * @return */ @Override public int compare(Order o1, Order o2) &#123; int numberOrder = o1.getOrderNumber() - o2.getOrderNumber(); int timeOrder = o1.getOrderTime().compareTo(o2.getOrderTime()); if(numberOrder == 0 &amp;&amp; timeOrder != 0) return timeOrder; else return numberOrder; &#125;&#125; 对应的单元测试:1234567891011121314151617181920212223242526272829303132 @Test void testComparator() &#123; ArrayList&lt;Order&gt; lists = new ArrayList&lt;&gt;(); lists.add(new Order(123,\"order 123\",LocalDate.of(2018,11,6))); lists.add(new Order(221,\"order 221\",LocalDate.of(2012,9,1))); lists.add(new Order(221,\"order 221\",LocalDate.of(2017,2,7))); lists.add(new Order(221,\"order 221\",LocalDate.of(2015,6,21))); lists.add(new Order(419,\"order 419\",LocalDate.of(2009,3,31))); System.out.println(\"未进行排序前的顺序:\"); for(Order order: lists)&#123; System.out.println(order); &#125; Collections.sort(lists,new SortByOrderNumberAndTime()); System.out.println(\"排序之后的顺序\"); for(Order order: lists)&#123; System.out.println(order); &#125; &#125;/*输出结果: 未进行排序前的顺序: 123 order 123 2018-11-06 221 order 221 2012-09-01 221 order 221 2017-02-07 221 order 221 2015-06-21 419 order 419 2009-03-31 排序之后的顺序 123 order 123 2018-11-06 221 order 221 2012-09-01 221 order 221 2015-06-21 221 order 221 2017-02-07 419 order 419 2009-03-31*/ 我们可以看到lists首先根据订单号然后根据时间先后顺序进行了排序，这里也是依据SortByOrderNumberAndTime类中实现的compare()方法进行的排序，并且在compare()里使用到了LocalDate类里的compareTo()方法去比较时间先后顺序，除了LocalDate,Java中许多常用的类也默认提供了对Comparable接口的实现，比如String、Integer、Character、Float、Byte基本数据类型的包装类，具体可以查看官网的Docs。 不论是Comparator接口还是Comparable接口，都是实现排序的一种方式，当然也可以结合一起使用，具体的使用方式还是得取决于最终的需求。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://swcheng.com/categories/JAVA/"},{"name":"DATA_STRACTURE","slug":"JAVA/DATA-STRACTURE","permalink":"http://swcheng.com/categories/JAVA/DATA-STRACTURE/"}],"tags":[{"name":"TECHNOLOGY","slug":"TECHNOLOGY","permalink":"http://swcheng.com/tags/TECHNOLOGY/"}]},{"title":"个人博客开始之旅","slug":"2018-10-19-博客开篇","date":"2018-10-19T14:24:00.000Z","updated":"2018-11-06T12:53:12.780Z","comments":true,"path":"2018/10/19/2018-10-19-博客开篇/","link":"","permalink":"http://swcheng.com/2018/10/19/2018-10-19-博客开篇/","excerpt":"其实一直以来都隐约有想写博客的想法，记得第一篇博客是发表在我的CSDN个人博客上的，内容是如何为Tomcat配置图片访问路径，以及在Eclipse下对Tomcat服务器目录的理解。之所以写那篇博客是因为这个服务器图片的配置困扰自己很长一段时间，好不容易解决了这个大问题，心情十分愉快就想着写篇博客记录下来，以便为存在有与我有一样需求的人提供帮助 ︿(￣︶￣)︿","text":"其实一直以来都隐约有想写博客的想法，记得第一篇博客是发表在我的CSDN个人博客上的，内容是如何为Tomcat配置图片访问路径，以及在Eclipse下对Tomcat服务器目录的理解。之所以写那篇博客是因为这个服务器图片的配置困扰自己很长一段时间，好不容易解决了这个大问题，心情十分愉快就想着写篇博客记录下来，以便为存在有与我有一样需求的人提供帮助 ︿(￣︶￣)︿ 但写那篇博客的时候自己对Markdown语法所知甚少，所以最终写出来的博客巨丑无比，自己最后看了都觉得辣眼睛 ┐(´∀｀)┌,所以之后自己的记录就基本存在于自己的YouDao云笔记上了。直到近来开始学习Web开发的相关知识之后，才觉得书写博客其实是一个很有趣的事情，自己不仅可以在个人博客上记录自己学习的技术知识，也可以记录一些生活上等其他的事情。之前在新浪微博上写过几篇，但总觉得新浪微博更是一个大杂烩一样的平台，所以写了两篇之后自己就想要开始搭建自己的个人博客平台。 当有搭建自己的个人博客的想法之后，刚开始的做法是想要通过搭建一个博客学习Node.js的相关知识的，自己也确实这么去做了，刚接触Nodejs的时候自己还顺带学习了MongoDB的知识，当然只是学习了一点皮毛，然后又去了解在Nodejs使用十分广泛的Express框架，以及与MongoDB交互的API等。但实在是当时需要学习的技术知识太多，时间跨度太大，以及由于准备寻找实习的原因，导致最后有始无终。╮(╯﹏╰）╭ 之后搭建个人博客的事情就一直搁置下来了，由于实习的原因在使用Java开发Web项目，后来自己又想使用Java去搭建一个个人博客，并因此了解到Java有一个非常流行的开源博客项目solo,star的数量达到了5k+,但是自己对于solo的主题却有点不满意，同时这个时候自己又了解到了Hexo Framework,看到hexo的第一眼，马上喜欢上了这个Nodejs博客框架，同时找到了一个自己非常喜欢的主题icarus,于是开始着手学习使用Hexo搭建自己的博客。使用Hexo搭建博客在官网完整的文档和视频说明帮助下，很顺利的完成了一个初步的本地部署并测试基本功能，这时候我就想着如何将这个站点发布提供给其他人访问。想要发布自己的博客站点有很多方式，但对于自己来说主要有下面三个选项: 部署到阿里云服务器 部署到Bandwagon服务器 部署到GithubPages 阿里云服务器对于学生来说特别便宜，大概120RMB/Year,使用阿里云服务器来部署站点的优点是IP地址在国内，访问速度会比较快，缺点是一但自己毕业之后，服务器的价格就不再是之前的价格了，即使是一个比较low的配置也需要不少的费用，下图是我在 2018/10/20 日去阿里云官网查看的轻量级应用服务器最低配置的价格。 (；′⌒`) 低收入人群表示真心付费不起，所以阿里云这个选项就被我给PASS掉了。至于 Bandwagon 云服务器，个人觉得 Bandwagon 是一个非常便宜实用的美国云服务器供应商，Bandwagon 在国内俗称”搬瓦工”,去年我购买的时候官网还没有被墙，现在已经无法访问了 (╯︵╰),哎这个长城防火墙实在是…反正自己是没法理解设计者的思想…个人觉得这个墙的弊远远大于利，不过这也是自己的个人想法，没有办法去改变现状。回到正题，下图是搬瓦工的官网界面: 我们可以看到最便宜的价格是19.9$,但是我们可以从网上找一找优惠码，可以优惠几美刀，毕竟1美刀可是相当6块多RMB呀。对于购买方案的选择，有一个不错的网站自己一直在用，地址是http://banwagong.cn/,感觉还不错，其实最低配以及满足我们普通用户的需求了，但是问题在于购买的VPS是否是选择的CN2直连线路，如果是CN2线路的话大概延迟会在 150~200ms 之间，个人觉得这个延迟时间是可以接受的。如果再为VPS配置Google的BBR拥塞控制的话，还可以降低一部分延迟，虽然降低的延迟不是很多，但毕竟实在是距离太远，能够做到降低一部分延迟已经很不错了。 自己平时使用 Bangwagong 主要是用于配置SSR服务，在自己摸不着头脑的时候用来Google寻找答案的，或者去查看一些官方站点的Doc，也偶尔看看Youtube视频啦 ٩(๑❛ᴗ❛๑)۶ 。所以这时候刚好碰上了部署站点的需求，所以就想这不是一举两得吗?不仅可以用来满足自己的翻墙需求还可以用来发布自己的博客，于是自己就开始为Hexo配置环境，目标主机是Cent OS7,自己也是倒腾一段时间才终于将所有需要配置的东西都配置好。但是当我在80端口运行自己的nginx服务之后，在自己的主机上居然访问不到nginx的页面？开始自己以为是某个地方配置的不对，后来想到可能是墙的锅，于是打开代理，打开代理之后顺利访问到了nginx默认页面，哎…这时候我的心情是复杂的…所有努力付诸东流 既然抵挡不过墙的力量，只能另想办法了，那么只剩下最后一个办法了，使用GitHubPages提供的云空间来发布自己的博客了。对于GithubPages这里就不做过多说明了，使用最多的方式是GithubPages和 Jekyll 来部署自己的个人站点，Jekyll的主题十分丰富，如果有兴趣可以去了解一下。我选择的是 Git本地客户端 + Node.js + Hexo Framework + Icarus + GithubPages + Atom 的方式去编写发布自己的个人博客。em…对于一个新人来说搭建这样一个完整的环境还是不太容易的…因为有太多没有接触的东西，但幸运的是Hexo的官网的文档十分简洁详细，并且之前自己使用过一点Nodejs,所以本地部署测试的过程还算比较顺利。 接下来就是如何发布自己的站点了，使用Hexo部署的deploy命令部署十分方便，但是这个命令的缺点是会将之前repository里的内容全部都干掉重新生成新的静态文件，这样的会导致自己在repository的CNAME和README文件都会被删除，这是自己没法忍受的缺点，所以只能放弃这个命令，转而自己使用Git的版本控制去手动更新新的文件。但是之前自己写的代码要么是通过IDE里自带的VCS要么是使用Github Desktop同步到Github上，感觉图形界面虽然操作方便但是让我对Git的工作方式一点都不了解，还是停留在无脑commit publish状态，想想自己使用了这么长时间的版本控制只会这两个基本的命令实在是惭愧呀。于是下定决心好好到Git的官网去学习关于版本控制的知识，Git官网有一本可以免费下载的Git Pro，提供多国语言翻译支持，自己就Download到kindle上平时上下班在公交车上阅读，这本书的详细叙述了版本控制的发展历史以及对比了Git与其它版本控制的区别，以及Git的所有使用情景，是一本十分优秀的书籍，很值得推荐一看。在将这本书啃完了前几章之后，就可以很轻松的使用Git command去管理Github的远程仓库了。 在我的cheng-github.github.io仓库下，我建立了两个分支，master和hexo。使用master分支存放生成的如html、css、images、js等静态页面文件,使用hexo分支存放本地测试的hexo文件，用作备份的需要。如果需要将原来的Gitpages的默认访问域名修改为个人域名可以进行相关配置，具体配置可以自行Google或者Baidu。 至此博客部署发布算是完成了，ヾ(๑╹◡╹)ﾉ”。希望自己不要忘记写博客的初心，也不要忘记当初决定学习计算机的初心，故而使用封面的图片用于提醒自己。em…最想对自己说… Follow your own voice,尽情去追逐自己想要的一切吧，即使跌倒也不要灰心，别让你眼底的光芒黯淡，that’s really alive.","categories":[{"name":"START","slug":"START","permalink":"http://swcheng.com/categories/START/"},{"name":"LIFE","slug":"LIFE","permalink":"http://swcheng.com/categories/LIFE/"}],"tags":[{"name":"FEELING","slug":"FEELING","permalink":"http://swcheng.com/tags/FEELING/"}]}]}
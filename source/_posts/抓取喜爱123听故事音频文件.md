layout: "post"
title: "抓取喜爱123音频文件"
date: "2018-11-24 20:25"
categories:
- [DATA SCRAPING]
tags:
- [TECHNOLOGY]
---
　　滴...你的表弟已上线，问你是否可以帮他把英语听力下载到他的MP3。(；′⌒`)...开始我以为他是不会如何将文件放在MP3的磁盘里面，就对他说将文件下载后放到移动磁盘就OK。然后他又说他老爸找不到下载地址，额....我心想下载地址你找不到我也没办法帮他去远程找下载地址呀...接着表弟就发了个微信分享的链接给我...但当时我不在宿舍，就说回去帮他看看。  
<!-- more -->  

![](/images/data_scraping/messgae_biaodi.png "来自表弟的消息 罒ω罒 ")  

　　回到宿舍已经是八点半，用电脑登录微信，打开表弟给的微信分享，其实就是使用微信的内置浏览器打开了一个地址。复制了链接地址改为使用Chrome打开，看到了下面的[在线听听力的界面](http://xiai123.com/rjbxmbyy9.html?from=groupmessage&isappinstalled=0)。

![](/images/data_scraping/xiai_chrome.png "表弟发来的MP3在线听地址")  

　　接下来把这个界面点了点，并没有发现听力的下载地址，看来是有意不提供下载地址，于是打开了调试模式查看网页对应的源码，想看看是否能在html界面中找到听力文件的地址，但是定位到对应的按钮点击的html代码，只看到了一个ul列表，里面的li标签只定义了一个class属性。看来音频地址是不会直接保存在html页面中的，(PS: 如果直接保存在html也太容易被获取到了吧) 于是接着查看它的源码。在chorme调试模式下定位到source tab页面，查看当前页面下的所有文件，显然我们的答案不可能存在css、img文件夹里，过滤掉css、img文件夹里的内容，仅关注js文件，下面两个文件出现在视野里:

![](/images/data_scraping/js文件列表.png "js文件列表")  
　　
　　那明显第一个是jquery在生产环境的名称，第二个文件叫***smusic.min.js***，里都有些什么内容呢?不妨打开看个究竟。这个js文件最外层是用一个 ***!function(l) {}(window);*** 包裹了一些方法的定义，一些变量的声明，但其中核心内容是设计者在其中定义了一个p对象，在js中对象的定义方式与函数声明的语法一样，区别定义一个函数还是一个对象取决于设计者使用它们的方式，如果定义的是一个对象，一般后续会使用 ***new xxx(...);*** 形式的语法去创建一个对象，而如果是作为方法调用则直接在js代码中使用 ***xxx(...);*** 形式的语法去执行调用。为什么说这个p是核心对象呢？原因是在对象p的prototype属性中定义了大量与播放音频文件相关的方法，这些方法包括 ***config、createListDom、setBuffer、resetPlayer、setVolume、initPlay、play、pause、getRandomIndex、playByMode、action、init*** ，顾名思义，init()方法中会执行一些初始化对象需要调用的方法和表达式，action()方法的内容是为不同的按钮添加点击事件，playByMode、play、pause、setVolume、resetPlayer则是与播放mp3音频操作相关的方法，config则是进行一些相关的配置...如果对这些方法具体的内容有兴趣，可以去仔细研究一下每一步它的执行，但在这里就不做过于详细的阐述了。  

**注意:**
- js中没有java中的继承，它实现不同对象间共享变量、方法的方式是使用一个共享的原型对象，在这个原型对象中定义的方法和变量可以在任何一个通过其构造函数创建的对象中直接使用  
- **!function(l) {}(window);　** 的作用与 **　(funcion(){})();** 一样，都是定义一个匿名函数接着进行对自身的调用，这种方式是在前面加上了!符号提示编译器这不是一个函数声明，而是一个表达式，从而实现与后者相同的效果。其它的运算符如 **+、-** 等也可以实现同样的作用，如果有兴趣可以研究一下它们之间的区别。  

　　粗略的研究了一下 ***smusic.min.js*** 的内容，下一步就可以通过断点来追踪具体的执行过程了，我选择的是将这个断点打在了p对象的构造函数里面调用init()方法的地方，结果如下图所示，下图需要关注的地方被红圈标注出来了。  

![](/images/data_scraping/breakpoint.png "断点")  
　　
　　在对象p的构造函数中很容易可以注意到,为config进行了赋值，接着调用了原型对象中的init()方法。在这个构造函数中，很容易注意到**musicList**变量，可以将这个变量添加到watch里面追踪值的变化，然后可以看到其具体的内容，明显这里的musicList是一个数组，数组里的内容如下图所示:  

![](/images/data_scraping/jsoncontent.png "数组里的内容")

　　显然这是一个json数组，里面的json对象包括了四个键值对，**title、cover、singer、src**，红色方框标注的内容是对应mp3文件的地址，这就是我们要寻找的东西啦。开始我的做法是在调试的时候直接将这个json数组里的内容copy到文件里，但是这样做会有一个问题，这个问题会导致我们拿不到正确的文件地址，原因是chrome在调试模式查看值的时候，如果一条记录的值过于长，不会显示所有的内容，而是会将结尾字符串的部分内容替换为...，但是我一开始并没有注意到这个问题，而是直接拿着这个url调用java的http api去下载，导致出现404错误，提示找不到对应的文件...刚开始我还以为这个站点做了安全措施...但是其实并没有...只是自己拿的方式有问题，正确的方式应该是使用**JSON.stringify()**将这个数组转为字符串，然后再存入到文件里。(当然也有将json字符串转换为对象的方法，需要使用**JSON.parse()**方法，注意参数需要使用单引号，因为json字符串的内容包含双引号，如果再使用双引号去包裹参数就会提示语法错误)

<p>　　到了这里其实已经完成的差不多了，下面都是Java需要解决的问题了，由于存在172条记录，如果手动去提取地址再下载未免太麻烦，所以我的做法是使用Java的io流读取这个文件里的内容到一个StringBuffer对象中，当然也可以使用StringBuilder，这两个的主要区别是StringBuffer是线程安全，StringBuilder不是线程安全的。由于我使用的是单线程下载，所以无论是使用StringBuffer还是StringBuilder其实都一样。将文件的内容读取到StringBuffer对象中之后，就可以愉快的进行我们想要的操作了。将所有的地址提取出来可以使用Java里的正则表达式，其核心的两个对象是<strong>Pattern</strong>和<strong>Matcher</strong>。匹配方式有三种，分别是matches、lookingAt、find，这三种的区别是matches是用于匹配整个字符串，就是说需要pattern和输入的字符串完全相等的时候才会返回true。lookingAt方法会匹配输入字符串的开头，仅当输入的字符串的开头部分满足匹配模式的时候返回true。find方法会扫描整个输入字符串，并且是逐个寻找满足条件的匹配模式，直到找不到匹配的内容为止。在这个需求里，匹配需要的地址就很容易啦，字符串内容的开头一定是<strong>http://ting.xiai123.com/mp3/</strong>，结尾一定是.mp3，这样去编写匹配模式就Ok。将匹配到的所有的url存入一个字符串数组中，接下来就是逐个去下载的问题啦，这里就不一一介绍了，自己踩的一个坑是将地址进行URLEncoder的时候选择了全部的地址，其实只需要将结尾部分进行重新编码就ok了，但是使用Java调用<strong>URLEncoder.encode()</strong>方法还存在着一个问题就是空白符会被替换成+，正确的替换结果应该是%20，无奈自己只能再调用一个replaceAll方法去替换。</p>

　　如果对这些代码有兴趣的话可以在这里下载，[https://github.com/cheng-github/DataStructure_Java/tree/master/src/test/java/download](https://github.com/cheng-github/DataStructure_Java/tree/master/src/test/java/download)。如果这个站点的源码有更多兴趣可以打一些断点，在Call Stack跟踪方法执行流程，以及Watch关键变量的值。  

　　这个网站没有作任何的保护措施，但是我还是一直弄到晚上一点才搞定，同时自己也发现抓取一个站点的数据其实是特别有意思的，听说Python对此有更强大的支持，赶紧去了解一下。(*´ﾟ∀ﾟ｀)ﾉ   

　　End















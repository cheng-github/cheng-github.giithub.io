layout: "post"
title: "求最大子序列和的四种实现方式"
date: "2018-11-18 16:20"
mathjax: true
categories:
- [JAVA,DATA_STRACTURE]
tags:
- [TECHNOLOGY]
---
　　在总结求最大子序列和的四种实现方式之前想谈谈为什么自己想要重新学习数据结构。之前在大二下学期的时候已经学过了数据结构这个课程，依稀记得老师一直提醒我们数据结构是计算机的核心课程，并且对于考研或者是找工作面试都是很重要的，特地提醒我们要重视这门课程，希望我们好好学习数据结构。当时自己在上数据结构这个课程之前已经使用过基本的数据结构-链表完成了大一下学期的一个C语言课程设计，记得那是自己使用C语言写的一个程序，虽然仅有一百多行，显示界面也只是一个小黑框，但完成的时候特别激动，因为那是自己真正意义上动手写的第一个完整程序。本来还想找到原来的代码运行一下，但发现自己前一段时间为了清理笔记本空间已经将自己之前写的关于C的代码都删除了** ╮(╯﹏╰）╭**
<!-- more -->
　　em....一个订餐管理程序，有显示当前订单列表、添加订餐信息、删除订餐信息、修改订餐信息、根据价格为订单排序、将已有订餐信息写入文件等几个简单的小功能，尤其是添加写入到文件这个模块的时候，自己遇到不知道如何解决的一个地方一直没法正常写入到文件，在CSDN上提问然后得到了一位前辈的指教才顺利的完成的这个功能，thanks　　( • ̀ω•́ )✧ 。这个程序当时给老师展示之后最后拿了93分的成绩，自己对于成绩倒不是特别在意，但这也是老师对自己的一种认可吧，更让自己开心的是探索的过程。那是自己第一次接触数据结构，被链表折磨的死去活来，去图书馆借书学习链表，一本看不懂就再借另外一本，读了好几本不同书籍关于链表的内容才开始慢慢理解它，至今还能回忆起当初冥思苦想的那几天。**(*￣∇￣*)** 

　　不知不觉又扯了这么远...回到正题，一个学期学习数据结构的时间肯定是不够的，更何况自己当时还并没有花特别多的时间去钻研数据结构，对于每种数据结构都仅仅是简单按照书上的例子实现了一遍，到了现在该忘都忘的差不多了...(╯︵╰) 但真正让我决定重新学习数据结构的原因不是自己想要温习知识，之前面试阿里的时候，面试结束的面试官问我有什么问题想要问他的，我觉得自己面试过程中回答的不好，所以就问面试官对于自己的学习有什么建议没有。面试官就说，培养一个掌握基本开发技能的普通程序员很容易，但数据结构是十分重要的，理解技术的原理也是十分重要的，还讲violate的原理给我听。加上之前在公司的季度技术交流会上，看见某位大佬秀了一波关于数据库方面的数据结构的知识，当时自己真是热血沸腾的感觉，并且那一刻真正的意识到是时候该找时间好好的学习数据结构了，于是才选择了**《数据结构与算法分析　Java语言描述》-Mark Allen Weiss**这本书，并计划一边学习这本书一边写博客记录学习过的内容。最后说一下自己的粗见吧，数据结构可能暂时在开发小型程序的作用还不是特别明显，搭建好开发环境之后，只要对某种语言比较熟练就可以做到业务上的实现，但是如果涉及到大型的应用的构建，当应用吞吐量很大的时候，一个小的细节对于应用整体的性能的作用就会比较明显了，这时候我们不仅需要了解使用到的技术的原理，而且需要更有技巧的编程，用更少的执行时间去完成相同的任务，相反而不是去粗暴的使用蛮力算法实现需求。所以从长远的角度来看，熟练掌握数据结构是十分必要的。  

　　最大子序列和，就是指在一个元素类型为整型的数组中，求其中连续的一个序列和的最大值，这个序列的开始下标可以是数组中的任意位置。如果我们按照列举所有可能情况的思考方式编写代码:  
- 第一种方式   
{% codeblock  lang:java %}
  public static void main(String[] args){
      int[] a = new int[]{ 19, 2, -20, 14, 35, -3, -21, 10, -22 };
      System.out.println(maxSubSum1(a));
  }

  /**
   * 最大子序列和,最简单直接的求最大子序和
   * @return
   */
  private static int maxSubSum1(int[] a){
      int maxSum = 0;

      for (int i = 0; i < a.length; i++) {
          for (int j = i; j < a.length; j++) {
              int thisSum = 0;

              for (int k = i; k <= j; k++) {
                  thisSum += a[k];
              }
              if(thisSum > maxSum){
                  maxSum = thisSum;
              }
          }
      }

      return maxSum;
  }
  /*  输出结果:
      50
  */
{% endcodeblock %}
　　很明显，这里的最大子序列和为前五个元素的和。下面我们分析一下该算法的时间复杂度。假设我们输入的数组的长度为***N***，忽略声明、调用方法、返回值的开销，仅关注嵌套的for循环所占用的时间，那么所耗费的时间为:　$ \displaystyle \sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^j1 $  

　　对该表达式从里到外求和:  
$$ \displaystyle \sum_{ k=i }^j1=j-i+1 $$
　　继续从里往外求和:  
$$ \displaystyle \sum_{ j=i }^{ N-1 }( j-i+1 )=\dfrac{( N-i+1 )( N-i )}{2} $$
　　所以有:  

　　$ \displaystyle \sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^j1 $　  

=　$ \displaystyle \sum_{ i=0 }^{ N-1 }{\dfrac{( N-i+1 )( N-i )}{2}} $  

=　$ \displaystyle \sum_{ i=1 }^{ N }{\dfrac{( N-i+2 )( N-i+1 )}{2}} $  

=　$ \displaystyle \sum_{ i=1 }^{ N }{ ( \dfrac{i^2}{2} - \dfrac{ 3i + 2iN }{ 2 } + \dfrac{N^2 + 3N + 2 }{ 2 } ) } $    

=　$ \displaystyle \dfrac12 \sum_{ i=1 }^{ N }{ i^2 } - (\dfrac{ 3+2N }{ 2 })\sum_{ i=1 }^{ N }{ i } + (\dfrac{N^2 + 3N + 2}{ 2 })\sum_{ i=1 }^{ N }{ 1 } $    

=　$ \displaystyle \dfrac12 \dfrac{ N(N+1)(N+2) }{6} - (\dfrac{ 3+2N }{ 2 })\dfrac{ N(N+1) }{2} + \dfrac{N^2 + 3N + 2}{ 2 }N  $  

=　$ \displaystyle  \dfrac{ N(N+1)(N+2) }{ 6 } $  

　　经计算可知该算法的时间复杂度为$ O(N^3) $，其实我们没有必要通过三层的for循环穷举所有的子序列的和，上面的第三层的for循环的计算明显存在冗余，仅仅两个for循环就可以满足求和需求:  
- 第二种方式  
{% codeblock  lang:java %}
    public static void main(String[] args){
            int[] a = new int[]{ 19, 2, -20, 14, 35, -3, -21, 10, -22 };
            System.out.println(maxSubSum2(a));
    }

    private static int maxSubSum2(int[] a){
        int maxSum = 0;
        for (int i = 0; i < a.length; i++) {
            int thisSum = 0;
            for (int j = i; j < a.length; j++) {
                thisSum += a[j];

                if(thisSum > maxSum){
                    maxSum = thisSum;
                }
            }
        }
        return maxSum;
    }
    /*  输出结果:
        50
    */
{% endcodeblock %}  

　　仅关注嵌套的for循环所占用的时间，那么所耗费的时间最多为: $ \displaystyle \sum_{ i=0 }^{ N-1 } \sum_{ j=i }^{ N-1 }3 $

　　对该表达式从里到外进行求和计算:
　　$ \displaystyle \sum_{ i=0 }^{ N-1 } \sum_{ j=i }^{ N-1 }3 $　  

=　$ \displaystyle 3\sum_{ i=0 }^{ N-1 }(N-i) $

=　$ \displaystyle 3\sum_{ i=1 }^{ N }( N-i+1 ) $

=　$ \displaystyle \dfrac{ 3N(N+1) }{ 2 } $

　　计算知第二种方法的时间复杂度为$ O(N^2) $。第二种方式避免了单独计算每个子序列结果的值，在第一种方式里，当第二层循环的j取最大值的时候，最里面的循环累加的结果包含了j取其它值的情况。而第二种方式正好避免这种冗余的计算，将每次累加的结果与当前最大的结果对比，从而降低了时间复杂度。以为这就是最优秀的方法了吗？然而编程思想的威力远没有这么简单，第三种方式采用了在算法设计中普遍采用的一种方式-***"分而治之"***:  

- 第三种方式
{% codeblock  lang:java %}
    public static void main(String[] args){
    //        int[] a = new int[]{ 19, 2, -20, 14, 35, -3, -21, 10, -22 };
        int[] a = new int[]{-11, -21, -5, -11, -42};
        System.out.println(maxSubSum3(a, 0, a.length - 1));
    }


    /**
     * 最大子序列和  第三种方式
     * @param a
     * @return
     */
    private static int maxSubSum3(int[] a,int left,int right){
        // 对于递归方法总会有一个基准情况，这里的left与right相等的时候就是我们这里例子的基准
        if( left == right ){
            if( a[ left ] > 0)
                return a[ left ];
            else
                return 0;
        }

        int center = (left + right) / 2;
        int maxLeftSum = maxSubSum3(a, left, center);
        int maxRightSum = maxSubSum3(a, center + 1, right);

        int maxLeftBorderSum = 0, leftBorderSum = 0;
        for (int i = center; i >= left; i--) {
            leftBorderSum += a[ i ];
            if( leftBorderSum > maxLeftBorderSum){
                maxLeftBorderSum = leftBorderSum;
            }
        }

        int maxRightBorderSum = 0, rightBorderSum = 0;
        for (int i = center + 1; i <= right; i++) {
            rightBorderSum += a[ i ];
            if(rightBorderSum > maxRightBorderSum){
                maxRightBorderSum = rightBorderSum;
            }
        }


        return max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);
    }

    private static int max3(int a,int b,int c){
        if (b > a || c > a){
            if(b > c)
                return b;
            else
                return c;
        } else {
            return a;
        }
    }

{% endcodeblock %}  

　　显然第三种方式的代码要比前两种复杂，但是复杂不是出发点，我们的目的是减少时间复杂度。在第三种方式中，核心方法是***int maxSubSum3(int[] a,int left,int right)***，递归方法往往都存在着一个基准情况，不然递归就会无限循环调用下去，程序也毫无意义了。在这里15-20行是这个递归方法的基准情况，方法中的23、24行中进行了对自身的调用。接下来分析这个代码是如何执行的，为了更清楚该代码的执行过程，我调试程序的时候特意注释掉了main方法之前在第一种方式和第二种方式使用到的参数，使用数量较少的参数去还原该算法整个过程。方法中有三个参数，***int[] a、int left、int right***，第一次传递到该方法中的实参是数组a的起始下标和结束下标，显然第一次调用该方法是不满足基准情况的，在不满足基准情况下继续往下执行，计算left和right的平均值，如果不能整除则取去掉小数位的数值。然后分别将center作为right的实参传递到***maxSubSum3()***为maxLeftSum赋值，center+1作为left的实参传递到***maxSubSum3()***为maxRightSum赋值。顾名思义，maxLeftSum和maxRightSum其实就是将数组分为左右两块之后左右两个数组的最大子序列和的值。但是我们怎么知道这两个变量的值是左右两个数组的最大子序列和的值呢？仅从外层去理解这个程序是无法得出这个结论的，我们不妨追溯到该程序的基准情况，left=right。  

　　当left与right相等的时候，程序会判断数组对应left的索引下标的值是否大于0，如果大于0，则返回对应值，小于0则返回0。显然这里就是该递归的基准情况了，当基准情况返回到上一层的调用，center的值必然与left是相等的，且right的值必然等于center+1。这个情况不难分析，因为　center = (left + right) / 2,且left与center相等，left不等于right,所以right必然等于center + 1。且该基准情况准只可能对应数组中的起始元素和结束元素，因为在递归调用中为maxLeftSum赋值的时候左边的参数不变，而center会不断减少直到与left相等，而其它方法中执行到了为maxLeftSum赋值的时候已经过了基准条件的筛选，同理为maxRightSum赋值的递归调用也是如此。明白了这一层关系，我们可以从程序的基准情况开始分析，下图的圆形表示从基准情况返回到上一层的时候，maxLeftSum以及maxRightSum的值,如果index对应0和1的值大于0则返回对应的值否则返回0:  

![](/images/maxSubSum/base1.jpg "最内层递归结束之后")  

　　26-40行的代码的意思是以中间的虚线左右两边的第一个元素为首元素分别开始往左右找出最大的子序列和，然后将左边与右边的最大的子序列的和相加，再在它和maxLeftSum、maxRightSum三个值中取最大值。当索引仅为0和1的时候这样处理肯定是可以拿到0、1组合的子数组的最大序列和，但如果递归的结果再往上一层，这样的处理是否依旧合适呢？当递归到第二层，上图递归的返回值为下图的maxLeftSum。下图展示了下一层递归的结果:(右边可能的Index有两种情况，一种是仅存在一个元素Index = 2，一种是存在元素Index = 2 和 Index = 3,这里我们为了更好的展示过程取两个元素的情况)

![](/images/maxSubSum/base2.jpg "递归第二层结束之后")  

　　这个时候如果还是按照之前的处理，取三者之间的最大值作为最大子序列和的结果是否合适呢？这里需要分情况讨论，现在我们可以确定的是maxLeftSum一定是左边数组最大的子序列的和，maxRightSum一定是右边数组最大的子序列的和。如果存在最大子序列的和不仅是单独取左边和右边里的元素，而是左右两边都需要取值构成最大子序列的和，那么这个对于整体而言的最大子序列一定是包含虚线左右两侧的元素的，因为一个子序列一定是连续的，这样的话就可以按照之前的方法分别从虚线开始往左右两边求最大子序列的和相加一定可以得到整个数组的最大子序列的和。如果不存在最大的子序列的和同时依赖于左和右两边的元素，我们针对maxLeftSum和maxRightSum取较大值即可得到最大子序列和。综合考虑上面两种情况，这样我们在这三个值中取最大值一定可以得到这个数组块的最大子序列和。这个可以递推到无论数组被分为多少块的情况，在数学的证明里也经常使用到这样的方式去证明一个定理，对于某个较小的情况条件成立，我们将这个较小的情况取为一般情况K，然后再证明K+1的情况成立，那么结论一定是成立的，数学里称为归纳假设，同样在这个情况下证明这个递归算法的正确性使用到了相似的方式。  

　　验证了这个算法的正确性之后，不可缺少的工作是去计算这个算法的时间复杂度。假设我们处理的数组长度为***N***，仅对***maxSubSum3(int[] a,int left,int right)***的执行时间进行计算，设其执行时间为T(N)。在这个方法内，15-20行的执行时间为一个常数时间量，设为T(1) = 1；对于26-40行的两个for循环，会遍历$ A_0 到 A_{ N-1 } $的每个元素，在每个循环内部耗费的时间都为常量，因此可设其执行时间为O(N)；接下来就是在23、24上两个递归方法的调用消耗的时间，这两行求解的数组长度大小为N/2，总计消耗的时间为2T(N/2)。忽略常数时间，可以得:  

$$  \displaystyle T(N) = T(\dfrac{N}{2}) + O(N) $$

　　 为了简化计算，我们可以使用N代替上式的O(N)，那么T(N) = 2T(N/2) + N,且有T(1) = 1,那么 T(2) = 2\*2 + 2 = 2\*2 = 4,T(4) = 2\*4 + 4 = 3\*4 = 12,T(8) = 2T(4) + 8 = 2\*12 + 8 = 4\*8 = 32,T(16) = 2T(8) + 16 = 2\*32 + 16 = 5\*16 = 80 ...... 即若$ N = 2^k $,则有:  

$$  \displaystyle T(N) = N * (k+1) = NlogN + N = O(NlogN) $$

　　 当然这里的计算结果是假设当$ N = 2^k $的情况，当N不是这个值的时候，需要一些更复杂的分析，但大O的结果是不变的。显然该算法的时间复杂度要比第二种方式低，本来以为到这里已经是最快的解决方式了，可是接下来还有一种比第三种方式时间复杂度更低的算法...而且实现起来居然更简单...不得不为思维的力量折服。 Ｏ(≧▽≦)Ｏ  

- 第四种方式
{% codeblock  lang:java %}
    public static void main(String[] args){
            int[] a = new int[]{11, -21, 5, 11, -42};
            System.out.println(maxSubSum4(a));
    }

    /**
     * 最大子序列求和   第四种写法
     * @param a
     * @return
     */
    private static int maxSubSum4(int[] a){
        int maxSum = 0, thisSum = 0;

        for (int i = 0; i < a.length; i++) {
            thisSum += a[ i ];

            if(thisSum > maxSum){
                maxSum = thisSum;
            }else if( thisSum < 0){
                thisSum = 0;
            }
        }

        return maxSum;
    } 
/*
  输出结果:
  16
*/
{% endcodeblock %}  

　　这个算法的时间复杂度可以看出来为O(N),但是粗看会质疑这个算法的正确性，因为这里仅有一个for循环去遍历数组中的值，难道这能就求出最大子序列的和？ (╬￣皿￣)=○ 　那我们之前的努力不是徒劳了？别着急，慢慢来看这个算法到底是怎么回事。  

　　分析程序可以得出，当thisSum为负值的时候，就选择抛弃前面的计算结果，选择从第一个非负值开始递增寻找最大子序列和。当在数组中前几个数字为负值的时候，这样的做法明显是正确的，因为负值不可能作为最大子序列和的开始。但是如果这样的一个序列出现在数组的中间的时候呢？我们假设从a[i]到a[j]出现了一个计算序列结果为负数的情况，那么假设可以从p(p为i+1到j之间的一个整数)开始得到一个比当前最大更大的子序列和，由于子序列必定是连续的，且从a[i]到a[p-1]的和是大于0的，那么很明显我们如果从a[i]开始要比从a[p]开始可以得到一个更大的子序列和。然后再做这样一个比较，从i开始和从j+1开始对比，如果存在一个从j+1开始的子序列的和比当前的最大的子序列大的情况，也是由于子序列的连续性，那么显然从j+1开始要比从i开始的值大，因为a[i]到a[j]的和是一个负数。所以如果出现负数的情况，如果后续还存在一个更大的子序列和，那么它的起点必然是在j之后而不可能在j之前。当然如果不存在从i+1开始存在比当前子序列更大的情况，我们继续累加也是不可能得出一个比当前最大子序列和更大的值。所以我们仅考虑存在比当前子序列更大的情况即可。如果存在从i+1开始比当前子序列更大的情况，综前所述，也必然出现在j之后。  

　　看似简单的程序其实蕴含了丰富的思考，掌握了这个求最大和问题的本质。 (=ﾟωﾟ)ﾉ

　　End





